<!DOCTYPE html><html><head><link href="META-INF/resources/webjars/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" /><link href="styles.css" rel="stylesheet" /><link rel="shortcut icon" type="image/png" href="favicon.png" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style>
.scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.05;
  text-decoration: none;
}


.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink{
  color: #777;
  opacity: 0.5;
  text-decoration: none;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:hover{
  opacity: 1.0;
}
.scalatex-site-Styles-hoverContainer:hover .scalatex-site-Styles-headerLink:active{
  opacity: 0.75;
}

.scalatex-site-Styles-content{
  color: #777;
  line-height: 1.6em;
  margin: 0 auto;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px;
  padding: 0 1em;
  padding-bottom: 50px;
}
.scalatex-site-Styles-content *{
  position: relative;
}
.scalatex-site-Styles-content p{
  text-align: justify;
}
.scalatex-site-Styles-content a:link{
  color: #37a;
  text-decoration: none;
}
.scalatex-site-Styles-content a:visited{
  color: #949;
  text-decoration: none;
}
.scalatex-site-Styles-content a:hover{
  text-decoration: underline;
}
.scalatex-site-Styles-content a:active{
  color: #000;
  text-decoration: underline;
}
.scalatex-site-Styles-content code{
  color: #000;
}

/*Workaround for bug in highlight.js IDEA theme*/
span.hljs-tag, span.hljs-symbol{
    background: none;
}
    </style><title>FastParse 0.4.4</title><script src="scripts.js"></script></head><body><div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-27464920-6', 'auto');
  ga('send', 'pageview');

</script>
<a href="https://github.com/lihaoyi/fastparse" style="position: absolute;top: 0px;right: 0px;border: 0;"><img src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" /></a>

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="FastParse0.4.4" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">FastParse 0.4.4<a class=" scalatex-site-Styles-headerLink" href="#FastParse0.4.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /><h2 style="font-weight: 300;color: #ccc;padding: 0px;margin-top: 0px;">Fast to write, Fast running Parsers in Scala</h2></div><div class=" scalatex-site-Styles-content">
    

<pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.all._

val number: P[Int] = P( CharIn('0'to'9').rep(1).!.map(_.toInt) )
val parens: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
val factor: P[Int] = P( number | parens )

val divMul: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~/ divMul).rep ).map(eval)
val expr: P[Int]   = P( addSub ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L19-L29" target="_blank"><i class="fa fa-link "></i></a></pre>
<pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Success(2, _) = expr.parse(&quot;1+1&quot;)
val Parsed.Success(15, _) = expr.parse(&quot;(1+1*2)+3*4&quot;)
val Parsed.Success(21, _) = expr.parse(&quot;((1+1*2)+(3*4*5))/3&quot;)
val Parsed.Failure(expected, failIndex, extra) = expr.parse(&quot;1+1*&quot;)
assert(expected == (number | parens), failIndex == 4)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L31-L36" target="_blank"><i class="fa fa-link "></i></a></pre>
<div id="splashdiv"></div>
<script>demo.DemoMain.math(document.getElementById("splashdiv"))</script>
<p>
    FastParse is a parser-combinator library for Scala that lets you quickly
    and easily write recursive descent <a href="#WritingParsers">text</a>-
    and <a href="#ByteParsers">binary data</a> parsers in Scala. Features
    include:
</p>
<ul>
    <li>
        <a href="#Performance">Up to 1/5 the speed of a hand-written parser</a>,
        100x faster than <a href="https://github.com/scala/scala-parser-combinators">scala-parser-combinators</a>, comparable
        (though slightly slower than) <a href="https://github.com/sirthias/parboiled2">Parboiled2</a></li>
    <li>
        1/10th the size of a hand-written parser</li>
    <li>
        Automatic, excellent <a href="#DebuggingParsers">error-reporting and diagnostics</a>.</li>
    <li>
        Able to write parsers for both <a href="#WritingParsers">structured text</a>
        as well as <a href="#ByteParsers">binary data</a>, using the same API</li>
    <li>
        <a href="#StreamingParsing">Streaming Parsing</a> of data-sets to avoid pre-loading
        everything into memory</li>
    <li>
        Compatible with both Scala-JVM and Scala.js
</li></ul>
<p>
    FastParse is a project by <a href="http://www.lihaoyi.com/">Li Haoyi</a>. If
    you use FastParse and enjoyed it, please chip in to support our development
    at <a href="https://www.patreon.com/lihaoyi">https://www.patreon.com/lihaoyi</a>.
    </p>
<p>
     The following sections will introduce you to FastParse and how to use it. You can also watch this talk:</p>
<iframe src="https://player.vimeo.com/video/142341803" width="800" height="450" style="margin-left: auto;margin-right: auto;display: block;" frameborder="0" webkitallowfullscreen="1" mozallowfullscreen="1" allowfullscreen="1"></iframe>
<p>
    Which will give you a quick 1-hour tour of how to use FastParse, the motivation behind the library, and how it fits into the bigger picture of how programmers parse unstructured text.
</p>
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="GettingStarted" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Getting Started<a class=" scalatex-site-Styles-headerLink" href="#GettingStarted" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        To begin using FastParse, add
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %% &quot;fastparse&quot; % &quot;0.4.4&quot;
</code></pre>
    <p>
        To your SBT configuration. To use with Scala.js, you'll need</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;fastparse&quot; % &quot;0.4.4&quot;
</code></pre>


    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="WritingParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Writing Parsers<a class=" scalatex-site-Styles-headerLink" href="#WritingParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <h1 id="Basic" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Basic" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Basic</h1>
        <p>
            The simplest parser matches a single string:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.all._
val parseA = P( &quot;a&quot; )

val Parsed.Success(value, successIndex) = parseA.parse(&quot;a&quot;)
assert(value == (), successIndex == 1)

val failure = parseA.parse(&quot;b&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.lastParser == (&quot;a&quot;: P0),
  failure.index == 0,
  failure.extra.traced.trace == &quot;&quot;&quot;parseA:1:1 / &quot;a&quot;:1:1 ...&quot;b&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L15-L27" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Such a parser returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code> if the input matches the string, and otherwise returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code>.</p>
        <p>
            As you can see, by default the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code> contains a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(): Unit</code>, unless you use <a href="#Capture">Capture</a> or <a href="#Map">Map</a> described below. Also, apart from the structured data of the failure, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code> also contains a nice human-readable trace of the parse showing the stack of parsers which were in progress when the parse failed. The trace can be obtained via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure.Extra.trace</code>.
</p>
        <p>
            You can also wrap the strings in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">IgnoreCase(&quot;...&quot;)</code> if you want the matching to be case-insensitive.
</p>
        <p>
            The <code>P(...)</code> lets you write mutually recursive parsers, without
            running into circular initialization problems, and gives the parser a
            nice, human-readable name (from the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">val</code>
            it is being assigned to) which appears in parse error messages.
            In general, every time you assign a parser
            to a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">val</code>, you should wrap it in <code>P(...)</code>.
</p>
        <h2 id="Sequence" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Sequence" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Sequence</h2>

            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( &quot;a&quot; ~ &quot;b&quot; )

val Parsed.Success(_, 2) = ab.parse(&quot;ab&quot;)

val Parsed.Failure(parser, 1, _) = ab.parse(&quot;aa&quot;)
assert(parser == (&quot;b&quot;: P0))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L30-L36" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                You can combine two parsers with the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code> operator. This creates a new parser that only succeeds if both left and right parsers succeed one after another.
</p>
        <h2 id="Repeat" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Repeat" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Repeat</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( &quot;a&quot;.rep ~ &quot;b&quot; )
val Parsed.Success(_, 8) = ab.parse(&quot;aaaaaaab&quot;)
val Parsed.Success(_, 4) = ab.parse(&quot;aaaba&quot;)

val abc = P( &quot;a&quot;.rep(sep=&quot;b&quot;) ~ &quot;c&quot;)
val Parsed.Success(_, 8) = abc.parse(&quot;abababac&quot;)
val Parsed.Failure(parser, 3, _) = abc.parse(&quot;abaabac&quot;)

val ab4 = P ( &quot;a&quot;.rep(min=2, max=4, sep=&quot;b&quot;) )
val Parsed.Success(_, 7) = ab4.parse(&quot;ababababababa&quot;)

val ab2exactly = P( &quot;ab&quot;.rep(exactly=2) )
val Parsed.Success(_, 4) = ab2exactly.parse(&quot;abab&quot;)

val ab4c = P ( &quot;a&quot;.rep(min=2, max=4, sep=&quot;b&quot;) ~ &quot;c&quot; )
val Parsed.Failure(_, 1, _) = ab4c.parse(&quot;ac&quot;)
val Parsed.Success(_, 4) = ab4c.parse(&quot;abac&quot;)
val Parsed.Success(_, 8) = ab4c.parse(&quot;abababac&quot;)
val Parsed.Failure(_, 7, _) = ab4c.parse(&quot;ababababac&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L38-L57" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> method creates a new parser that attempts to parse the given parser zero or more times.
                If you want to parse something a given number of times, you can use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(min = 2, max = 4)</code> o
                r the shorter <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(1)</code> for one or more times,
                in addition there is <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">exactly</code> parameter that if it's defined behaves
                like <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">min</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">max</code> equals to it.
                You can optionally provide an argument which acts as a separator between the usages of the original parser,
                such as a comma in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(sep = &quot;,&quot;)</code>.
</p>
        <h2 id="Optional" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Optional" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Optional</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val option = P( &quot;c&quot;.? ~ &quot;a&quot;.rep(sep=&quot;b&quot;).! ~ End)

val Parsed.Success(&quot;aba&quot;, 3) = option.parse(&quot;aba&quot;)
val Parsed.Success(&quot;aba&quot;, 3) = option.parse(&quot;aba&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L60-L64" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Similar to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> is <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code>, which creates a new parser that attempts to parse the given parser zero or 1 times.
</p>
        <h2 id="Either" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Either" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Either</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val either = P( &quot;a&quot;.rep ~ (&quot;b&quot; | &quot;c&quot; | &quot;d&quot;) ~ End)

val Parsed.Success(_, 6) = either.parse(&quot;aaaaab&quot;)
val Parsed.Failure(parser, 5, _) = either.parse(&quot;aaaaae&quot;)
assert(parser == (&quot;b&quot; | &quot;c&quot; | &quot;d&quot;))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L67-L72" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">|</code> operator tries the parser on the left, and if that fails, tries the one on the right, failing only if both parsers fail.
</p>
        <h2 id="End,Start" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#End,Start" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>End, Start</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val noEnd = P( &quot;a&quot;.rep ~ &quot;b&quot;)
val withEnd = P( &quot;a&quot;.rep ~ &quot;b&quot; ~ End)

val Parsed.Success(_, 4) = noEnd.parse(&quot;aaaba&quot;)
val Parsed.Failure(End, 4, _) = withEnd.parse(&quot;aaaba&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L76-L82" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">End</code> parser only succeeds if at the end of the input string. By default, a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code> does not need to consume the whole input, and can succeed early consuming a portion of it (exactly how much input was consumed is stored in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success#index</code> attribute). By using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">End</code>, we can make the parse fail if it doesn't consume everything
</p>
            <p>
                There is also a similar <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Start</code> parser, which only succeeds at the start of the input</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( ((&quot;a&quot; | Start) ~ &quot;b&quot;).rep ~ End).!

val Parsed.Success(&quot;abab&quot;, 4) = ab.parse(&quot;abab&quot;)
val Parsed.Success(&quot;babab&quot;, 5) = ab.parse(&quot;babab&quot;)

val Parsed.Failure(parser, 2, _) = ab.parse(&quot;abb&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L84-L91" target="_blank"><i class="fa fa-link "></i></a></pre>

        <h2 id="Pass,Fail" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Pass,Fail" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Pass, Fail</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Success((), 0) = Pass.parse(&quot;asdad&quot;)
val Parsed.Failure(Fail, 0, _) = Fail.parse(&quot;asdad&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L94-L96" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                These two parsers always succeed, or always fail, respectively. Neither consumes any input.
</p>
        <h2 id="Index" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Index" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Index</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val finder = P( &quot;hay&quot;.rep ~ Index ~ &quot;needle&quot; ~ &quot;hay&quot;.rep )

val Parsed.Success(9, _) = finder.parse(&quot;hayhayhayneedlehay&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L99-L102" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Always succeeds, and provides the current index of the parse into the input string. e.g. useful for providing source locations for AST nodes. Consumes no input.
</p>
        <h2 id="Capture" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Capture" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Capture</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val capture1 = P( &quot;a&quot;.rep.! ~ &quot;b&quot; ~ End)

val Parsed.Success(&quot;aaa&quot;, 4) = capture1.parse(&quot;aaab&quot;)

val capture2 = P( &quot;a&quot;.rep.! ~ &quot;b&quot;.! ~ End)

val Parsed.Success((&quot;aaa&quot;, &quot;b&quot;), 4) = capture2.parse(&quot;aaab&quot;)

val capture3 = P( &quot;a&quot;.rep.! ~ &quot;b&quot;.! ~ &quot;c&quot;.! ~ End)

val Parsed.Success((&quot;aaa&quot;, &quot;b&quot;, &quot;c&quot;), 5) = capture3.parse(&quot;aaabc&quot;)

val captureRep = P( &quot;a&quot;.!.rep ~ &quot;b&quot; ~ End)

val Parsed.Success(Seq(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;), 4) = captureRep.parse(&quot;aaab&quot;)

val captureOpt = P( &quot;a&quot;.rep ~ &quot;b&quot;.!.? ~ End)

val Parsed.Success(Some(&quot;b&quot;), 4) = captureOpt.parse(&quot;aaab&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L105-L124" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                So far, all the parsers go over the input text but do not return any useful value: the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success#value</code> attribute was always <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">()</code>. In order to make them do so, you use the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.!</code> operation to capture the section of the input string the parser parsed.</p>
            <p>
                Note the types of each parser:</p>
            <ul>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture1</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[String]</code></li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture2</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[(String, String)]</code></li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">capture3</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[(String, String, String)]</code></li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">captureRep</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[String]]</code></li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">captureOpt</code> is a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Option[String]]</code></li></ul>
            <p>
                In general, if you have a parser of type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TupleN</code>, capturing one more section turns it into a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TupleN+1</code>. Furthermore, if you capture within a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code> optional parser, it becomes a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[T]]</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Option[T]]</code> respectively
</p>
        <h2 id="AnyChar" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#AnyChar" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>AnyChar</h2>
            <i>
                See also <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">AnyElem</code> in <a href="#Abstraction">Abstraction</a></i>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ab = P( &quot;'&quot; ~ AnyChar.! ~ &quot;'&quot; )

val Parsed.Success(&quot;-&quot;, 3) = ab.parse(&quot;'-'&quot;)

val Parsed.Failure(parser, 2, _) = ab.parse(&quot;'-='&quot;)
assert(parser == (&quot;'&quot;: P0))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L147-L153" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                This parser parses any single character successfully. It almost
                always succeeds, except if there simply aren't any characters left
                to parse.
</p>
            <p>
                There is also a plural <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">AnyChars(count: Int)</code> version that
                parses exactly <code>count</code> characters in a row, regardless of
                what they are.
</p>
        <h2 id="PositiveLookahead" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#PositiveLookahead" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Positive Lookahead</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val keyword = P( (&quot;hello&quot; ~ &amp;(&quot; &quot;)).!.rep )

val Parsed.Success(Seq(&quot;hello&quot;), _) = keyword.parse(&quot;hello &quot;)
val Parsed.Success(Seq(), __) = keyword.parse(&quot;helloX&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L157-L161" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&amp;(...)</code> operator wraps a parser, only succeeds if it succeeds, but consumes no input. Useful for doing checks like &quot;these characters must be followed by a whitespace, but don't consume the whitespace&quot;
</p>
        <h2 id="NegativeLookahead" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NegativeLookahead" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Negative Lookahead</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val keyword = P( &quot;hello&quot; ~ !&quot; &quot; ~ AnyChar ~ &quot;world&quot; ).!

val Parsed.Success(&quot;hello-world&quot;, _) = keyword.parse(&quot;hello-world&quot;)
val Parsed.Success(&quot;hello_world&quot;, _) = keyword.parse(&quot;hello_world&quot;)

val Parsed.Failure(parser, 6, _) = keyword.parse(&quot;hello world&quot;)
assert(parser == !(&quot; &quot;))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L163-L170" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">!...</code> operator wraps a parser and only succeeds if it fails, also consuming no input. Useful to combine with other parsers like <a href="#AnyChar">AnyChar</a> to restrict the things that they can parse.</p>
        <h2 id="Map" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Map" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Map</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val binary = P( (&quot;0&quot; | &quot;1&quot; ).rep.! )
val binaryNum = P( binary.map(Integer.parseInt(_, 2)) )

val Parsed.Success(&quot;1100&quot;, _) = binary.parse(&quot;1100&quot;)
val Parsed.Success(12, _) = binaryNum.parse(&quot;1100&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L172-L177" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                Up till now, we've only dealt with</p>
            <ul>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Unit]</code>: the default case</li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[String]</code>: after capturing something with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.!</code></li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[TupleN[String]]</code>: capturing multiple things in series</li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[String]]</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Option[String]]</code>: capturing things in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.?</code>
</li></ul>
            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.map</code> lets you convert an arbitrary <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]</code> into a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[V]</code> by providing a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T =&gt; V</code> function. This is useful for converting the strings and tuples/seqs/options of strings into more useful data-structures.</p>
        <h2 id="FlatMap" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#FlatMap" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>FlatMap</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val leftTag = P( &quot;&lt;&quot; ~ (!&quot;&gt;&quot; ~ AnyChar).rep(1).! ~ &quot;&gt;&quot; )
def rightTag(s: String) = P( &quot;&lt;/&quot; ~ s.! ~ &quot;&gt;&quot; )
val xml = P( leftTag.flatMap(rightTag) )

val Parsed.Success(&quot;a&quot;, _) = xml.parse(&quot;&lt;a&gt;&lt;/a&gt;&quot;)
val Parsed.Success(&quot;abcde&quot;, _) = xml.parse(&quot;&lt;abcde&gt;&lt;/abcde&gt;&quot;)

val failure = xml.parse(&quot;&lt;abcde&gt;&lt;/edcba&gt;&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.extra.traced.trace == &quot;&quot;&quot;xml:1:1 / rightTag:1:8 / &quot;abcde&quot;:1:10 ...&quot;edcba&gt;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L179-L190" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> allows you to dynamically choose a parser to continue with, given the result of the current parser. The example above uses it to parse balanced XML tags. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> can be used to parse indentation-based grammars, and is used to do so in <a href="http://lihaoyi.github.io/Scalatex/">Scalatex</a>.
</p>
            <p>
                Note that the function given to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> is evaluated every time this parser is tried. You should be conscious of the cost of re-creating the resultant parser every time, since FastParse parsers are somewhat expensive to initialize despite being fast per-run. If possible, store the parsers somewhere before-hand or memo-ize/cache them to avoid initializing them wastefully.</p>
            <p>
                As is normal in Scala, you can replace a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> call with a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">for</code>-comprehension, as below:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val leftTag = P( &quot;&lt;&quot; ~ (!&quot;&gt;&quot; ~ AnyChar).rep(1).! ~ &quot;&gt;&quot; )
def rightTag(s: String) = P( &quot;&lt;/&quot; ~ s.! ~ &quot;&gt;&quot; )
val xml = P(
  for{
    s &lt;- leftTag
    right &lt;- rightTag(s)
  } yield right
)

val Parsed.Success(&quot;a&quot;, _) = xml.parse(&quot;&lt;a&gt;&lt;/a&gt;&quot;)
val Parsed.Success(&quot;abcde&quot;, _) = xml.parse(&quot;&lt;abcde&gt;&lt;/abcde&gt;&quot;)

val failure = xml.parse(&quot;&lt;abcde&gt;&lt;/edcba&gt;&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.extra.traced.trace == &quot;&quot;&quot;xml:1:1 / rightTag:1:8 / &quot;abcde&quot;:1:10 ...&quot;edcba&gt;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L192-L208" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Which is equivalent and behaves exactly the same.
</p>
        <h2 id="Filter" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Filter" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Filter</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P(CharIn('0' to '9').rep(1).!).map(_.toInt)
val even = digits.filter(_ % 2 == 0)
val Parsed.Success(12, _) = even.parse(&quot;12&quot;)
val failure = even.parse(&quot;123&quot;).asInstanceOf[Parsed.Failure]
assert(&quot;&quot;&quot;digits.filter\(.*\)$&quot;&quot;&quot;.r.findPrefixOf(even.toString).isDefined)
assert(&quot;&quot;&quot;digits.filter\(.*\):1:1 ...&quot;123&quot;$&quot;&quot;&quot;.r.findPrefixOf(failure.extra.traced.trace).isDefined)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L210-L216" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.filter</code> allows you to supply a predicate <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T =&gt; Boolean</code> which is applied to the successful result of the current parser. If the predicate is true the filtered parser succeeds otherwise it fails. The example above uses <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.filter</code> on digits to parse only even numbers successfully while odd numbers will fail. If the current parser fails then that failure is simply passed along.</p>
        <h2 id="Opaque" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Opaque" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Opaque</h2>
            <p>
                Sometimes it's useful to hide parser's implementation details and provide a higher-level error message. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.opaque</code> achieves exactly that.</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digit = CharIn('0' to '9')
val letter = CharIn('A' to 'Z')
def twice[T](p: Parser[T]) = p ~ p
def errorMessage[T](p: Parser[T], str: String) =
  ParseError(p.parse(str).asInstanceOf[Parsed.Failure]).getMessage

// Portuguese number plate format since 2006
val numberPlate = P(twice(digit) ~ &quot;-&quot; ~ twice(letter) ~ &quot;-&quot; ~ twice(digit))

assert(errorMessage(numberPlate, &quot;11-A1-22&quot;) == &quot;&quot;&quot;
  |found &quot;1-22&quot;, expected CharIn(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;) at index 4
  |11-A1-22
  |    ^&quot;&quot;&quot;.stripMargin.trim)

// Suppress implementation details from the error message
val opaqueNumberPlate = numberPlate.opaque(&quot;&lt;number-plate&gt;&quot;)

assert(errorMessage(opaqueNumberPlate, &quot;11-A1-22&quot;) == &quot;&quot;&quot;
  |found &quot;11-A1-22&quot;, expected &lt;number-plate&gt; at index 0
  |11-A1-22
  |^&quot;&quot;&quot;.stripMargin.trim)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L218-L239" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.opaque</code> wraps the target parser in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Opaque</code> combinator, which only succeeds or fails as a single entity and leaves no traces of underlying parsers on the stack.
</p>
        <h2 id="Log" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Log" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Log</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val logged = mutable.Buffer.empty[String]
implicit val logger = Logger(logged.append(_))

val DeepFailure = P( &quot;C&quot; )
val Foo = P( (DeepFailure.log() | &quot;A&quot;.log()) ~ &quot;B&quot;.!.log() ).log()

Foo.parse(&quot;AB&quot;)

val allLogged = logged.mkString(&quot;\n&quot;)

val expected =
  &quot;&quot;&quot;+Foo:1:1
    |  +DeepFailure:1:1
    |  -DeepFailure:1:1:Failure(DeepFailure:1:1 / &quot;C&quot;:1:1 ...&quot;AB&quot;)
    |  +&quot;A&quot;:1:1
    |  -&quot;A&quot;:1:1:Success(1:2)
    |  +&quot;B&quot;:1:2
    |  -&quot;B&quot;:1:2:Success(1:3)
    |-Foo:1:1:Success(1:3)
    |
  &quot;&quot;&quot;.stripMargin.trim
assert(allLogged == expected)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MiscTests.scala#L74-L96" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                <a href="#DebuggingParsers">Debugging Parsers</a> is often done with the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> method, which logs output whenever the parser is tried, and when it succeeds or fails, together with the location and other data when these things happen (traces on failures, results on successes, the presence of <a href="#Cuts">Cuts</a>, ...). You can define custom loggers as we've done here, or you can just leave it to by default print to stdout.
</p>
            <p>
                Generally, if a parser is doing something wrong, the workflow is:
</p>
            <ul>
                <li>
                    Add a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> to the parser which is misbehaving</li>
                <li>
                    See where it's being tried, and what it's result (success/failure) is, and confirm that it is misbehaving.</li>
                <li>
                    Look at the parsers it's made of; which one of them is misbehaving and causing the larger parser to misbehave?</li>
                <li>
                    Add <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code>s to all of them</li>
                <li>
                    Identify which of the sub-parsers is misbehaving</li>
                <li>
                    Repeat</li></ul>
            <p>
                It's a non-trivial process, but it is generally not hard to figure out what's happening this way.
</p>
    <h1 id="Intrinsics" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Intrinsics" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Intrinsics</h1>
        <p>
            In theory, all possible parsers can be put together using the above tools. In practice, a few more tools are provided for convenience or performance:
</p>
        <h2 id="CharPred" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharPred" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharPred</h2>
            <i>
                See also <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ElemPred</code> in <a href="#Abstraction">Abstraction</a></i>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val cp = P( CharPred(_.isUpper).rep.! ~ &quot;.&quot; ~ End )

val Parsed.Success(&quot;ABC&quot;, _) = cp.parse(&quot;ABC.&quot;)
val Parsed.Failure(_, 2, _) = cp.parse(&quot;ABc.&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L243-L247" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharPred</code> takes a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Char =&gt; Boolean</code> predicate and creates a parser that parses any single character that satisfies that predicate. e.g. you can use any of the helpful methods on <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">scala.Char</code> to check if a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Char</code> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isUpper</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isDigit</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">isControl</code>, etc. etc.
</p>
            <p>
                Note that this builds a high-performance bit-packed lookup table, the size of the range of valid characters, up to 65k. That means that creating a parser like this has a one-time cost in terms of memory (up to 8k bytes) and time. This should not matter as FastParse parsers are long-lived and re-usable, though you may want to consciously avoid creating too many of these repeatedly.
</p>
            <p>
                You can use <code>CharPred.raw</code> if you want to avoid pre-computing the lookup table, in which case the predicate is re-run repeatedly during parsing.
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val cp = P( CharPred.raw(_.isUpper).rep.! ~ &quot;.&quot; ~ End )

val Parsed.Success(&quot;ABC&quot;, _) = cp.parse(&quot;ABC.&quot;)
val Parsed.Failure(_, 2, _) = cp.parse(&quot;ABc.&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L249-L253" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                This could be useful if you find your parsers are taking too long to
                initialize and don't mind sacrificing a bit of steady-state
                performance.
</p>
        <h2 id="CharIn" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharIn" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharIn</h2>
            <i>
                See also <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ElemIn</code> in <a href="#Abstraction">Abstraction</a>
</i>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val ci = P( CharIn(&quot;abc&quot;, &quot;xyz&quot;).rep.! ~ End )

val Parsed.Success(&quot;aaabbccxyz&quot;, _) = ci.parse(&quot;aaabbccxyz&quot;)
val Parsed.Failure(_, 7, _) = ci.parse(&quot;aaabbccdxyz.&quot;)

val digits = P( CharIn('0' to '9').rep.! )

val Parsed.Success(&quot;12345&quot;, _) = digits.parse(&quot;12345abcde&quot;)
val Parsed.Success(&quot;123&quot;, _) = digits.parse(&quot;123abcde45&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L255-L264" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Similar to <a href="#CharPred">CharPred</a>, except you pass in sequences of valid characters rather than a predicate.
</p>
            <p>
                <code>CharIn</code> also builds a lookup table which it uses during parsing. As a result, it's much faster to execute than if you had used <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | ...</code> to combine a bunch of single-character parsers together. The same warning as <a href="#CharPred">CharPred</a> about the one time cost-of-construction applies.

</p>
        <h2 id="CharsWhile" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharsWhile" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharsWhile</h2>
            <i>
                See also <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ElemsWhile</code> in <a href="#Abstraction">Abstraction</a>
</i>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val cw = P( CharsWhile(_ != ' ').! )

val Parsed.Success(&quot;12345&quot;, _) = cw.parse(&quot;12345&quot;)
val Parsed.Success(&quot;123&quot;, _) = cw.parse(&quot;123 45&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L267-L271" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                A repeated version of <a href="#CharPred">CharPred</a>: this parser continually chomps away at characters as long as they continue passes the given predicate.
</p>
            <p>
                This is a very fast parser, ideal for quickly consuming large numbers of characters. The same warning as <a href="#CharPred">CharPred</a> about the one time cost-of-construction applies.</p>
            <p>
                You can use <code>CharsWhile.raw</code> if you want to avoid pre-computing the lookup table, in which case the predicate is re-run repeatedly during parsing.
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val cw = P( CharsWhile.raw(_ != ' ').! )

val Parsed.Success(&quot;12345&quot;, _) = cw.parse(&quot;12345&quot;)
val Parsed.Success(&quot;123&quot;, _) = cw.parse(&quot;123 45&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L279-L283" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                This could be useful if you find your parsers are taking too long to
                initialize and don't mind sacrificing a bit of steady-state
                performance.
</p>
        <h2 id="CharsWhileIn" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CharsWhileIn" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CharsWhileIn</h2>
            <i>
                See also <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ElemsWhileIn</code> in <a href="#Abstraction">Abstraction</a>
</i>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val cw = P( CharsWhileIn(&quot;123456789&quot;).! )

val Parsed.Success(&quot;12345&quot;, _) = cw.parse(&quot;12345&quot;)
val Parsed.Success(&quot;123&quot;, _) = cw.parse(&quot;123 45&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L273-L277" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                A combination of <a href="#CharsWhile">CharsWhile</a> and <a href="#CharIn">CharIn</a>, this
                parser continues consuming characters as long as they are within
                the set you characters you passed to it.</p>
            <p>
                If you find yourself using <a href="#CharsWhile">CharsWhile</a> with <code>contains</code>
                e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile(&quot;abc&quot;.contains)</code>, you probably could
                use <code>CharsWhileIn</code> instead.</p>
        <h2 id="StringIn" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StringIn" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>StringIn</h2>
            <i>
                See also <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">SeqIn</code> in <a href="#Abstraction">Abstraction</a></i>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val si = P( StringIn(&quot;cow&quot;, &quot;cattle&quot;).!.rep )

val Parsed.Success(Seq(&quot;cow&quot;, &quot;cattle&quot;), _) = si.parse(&quot;cowcattle&quot;)
val Parsed.Success(Seq(&quot;cow&quot;), _) = si.parse(&quot;cowmoo&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L285-L289" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Quickly parses one of any number of strings that you give it. Behind the scenes, it converts the list of strings into a Trie so it can attempt to parse all of them in a single pass.
</p>
            <p>
                As a result, this is much faster to execute than if you had combined the individual strings with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;cow&quot; | &quot;cattle&quot; | ...</code>.
</p>
            <p>
                There is also a <code>StringInIgnoreCase</code> parser you can use
                if you want to match things case-insensitively.</p>
    <h1 id="Cuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Cuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Cuts</h1>
        <p>
            A &quot;cut&quot; (<code>~/</code> in Fastparse) is a marker in a recursive-descent
            parser that states &quot;you cannot backtrack past this point&quot;. In
            FastParse, this serves two purposes:
</p>
        <ul>
            <li>
                Improving the quality of error-reporting while
                <a href="#DebuggingParsers">Debugging Parsers</a>: whether it's the parser that's
                incorrect or the input that's incorrect, the improved error
                messages due to Cuts makes it easier to figure out what's wrong</li>
            <li>
                Allowing <a href="#StreamingParsing">Streaming Parsing</a>: Even when parsing
                streaming input, FastParse parsers have to buffer the input
                in-memory in case the parser needs to backtrack, but adding
                Cuts tells the parser it can safely drop earlier parts of the
                input it can no longer backtrack to.
</li></ul>
        <h2 id="NoCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NoCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>No Cuts</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val nocut = P( &quot;val &quot; ~ alpha.rep(1).! | &quot;def &quot; ~ alpha.rep(1).!)

val Parsed.Success(&quot;abcd&quot;, _) = nocut.parse(&quot;val abcd&quot;)

val failure = nocut.parse(&quot;val 1234&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.index == 0,
  failure.extra.traced.trace ==
  &quot;&quot;&quot;nocut:1:1 / (&quot;val &quot; ~ alpha.rep(1) | &quot;def &quot; ~ alpha.rep(1)):1:1 ...&quot;val 1234&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L293-L304" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                Above we have a naive scala definition parser: it either parses a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">val</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def</code>, a space, and its (lower-case only) name. On a success this works as expected, and extracts the name. However, on a failure, something odd happens: the deepest parser on-failure is shown to be the entire <a href="#Either">Either</a>, rather than just the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">alpha</code> that came after <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;val &quot;</code>. Why is that?
</p>
            <p>
                By default, the parse has an opportunity to backtrack whenever it enters a
</p>
            <ul>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1 | p2</code>: If <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1</code> fails, it tries <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p2</code>
</li>
                <li>
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p.rep</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p.?</code>: If parsing with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p</code> fails, it backtracks out of the failed parse and tries to parse whatever comes after the repeat/optional.</li></ul>
            <p>
                e.g. in the case of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1 | p2</code>, if it tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p1</code> and fails, it then tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">p2</code>. If <i>that</i> fails, all that FastParse knows is that one of them should have succeeded. Specifically, FastParse does <i>not</i> know that after successfully parsing <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;val &quot;</code>, that only the left branch of the <a href="#Either">Either</a> is viable! Thus it has no choice but to offer both alternatives in the error message.
</p>
        <h2 id="Cuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Cuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Cuts</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val nocut = P( &quot;val &quot; ~/ alpha.rep(1).! | &quot;def &quot; ~/ alpha.rep(1).!)

val Parsed.Success(&quot;abcd&quot;, _) = nocut.parse(&quot;val abcd&quot;)

val failure = nocut.parse(&quot;val 1234&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.index == 4,
  failure.extra.traced.trace ==
  &quot;&quot;&quot;nocut:1:1 / alpha:1:5 / CharIn(&quot;abcdefghijklmnopqrstuvwxyz&quot;):1:5 ...&quot;1234&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L306-L317" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Cuts are added using the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code> operator, which is similar to the <a href="#Sequence">Sequence</a> operator <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code>. Once the parse has crossed a cut, it can no longer backtrack past the point at which the cut occured. Hence, in this case you can see that it no longer backtracks to index 0, out of the enclosing <a href="#Either">Either</a> parser and offering that in the error trace. Instead, it shows a much more precise error: at index <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">4</code>, expecting one of the small set of alphanumeric characters.</p>
            <p>
                In general, if you know that a parser is &quot;committed&quot; to one branch after parsing to a certain point, adding a cut will greatly improve the error message by ensuring that the parser <i>itself</i> knows that. Good places to add cuts include places like after keywords in a programming language parser, where a keyword can be followed by only one thing and anything else is an error.</p>
        <h2 id="RepCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#RepCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Rep Cuts</h2>

            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val stmt = P( &quot;val &quot; ~ alpha.rep(1).! ~ &quot;;&quot; ~ &quot; &quot;.rep )
val stmts = P( stmt.rep(1) ~ End )

val Parsed.Success(Seq(&quot;abcd&quot;), _) = stmts.parse(&quot;val abcd;&quot;)
val Parsed.Success(Seq(&quot;abcd&quot;, &quot;efg&quot;), _) = stmts.parse(&quot;val abcd; val efg;&quot;)

val failure = stmts.parse(&quot;val abcd; val &quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.index == 10,
  failure.extra.traced.trace == &quot;&quot;&quot;stmts:1:1 / (End | &quot; &quot;):1:11 ...&quot;val &quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L319-L331" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                A similar problem occurs inside <a href="#Repeat">Repeat</a> or <a href="#Optional">Optional</a> parsers, where the parser will give up and backtrack out if it fails, even if it really should succeed. Again, adding cuts would result in a more precise error message:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val alpha = P( CharIn('a' to 'z') )
val stmt = P( &quot;val &quot; ~/ alpha.rep(1).! ~ &quot;;&quot; ~ &quot; &quot;.rep )
val stmts = P( stmt.rep(1) ~ End )

val Parsed.Success(Seq(&quot;abcd&quot;), _) = stmts.parse(&quot;val abcd;&quot;)
val Parsed.Success(Seq(&quot;abcd&quot;, &quot;efg&quot;), _) = stmts.parse(&quot;val abcd; val efg;&quot;)

val failure = stmts.parse(&quot;val abcd; val &quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.index == 14,
  failure.extra.traced.trace ==
    &quot;&quot;&quot;stmts:1:1 / stmt:1:11 / alpha:1:15 / CharIn(&quot;abcdefghijklmnopqrstuvwxyz&quot;):1:15 ...&quot;&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L333-L346" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Another case where you may want to pay attention is when you are using delimiters with your <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> calls:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P( CharIn('0' to '9').rep(1) )
val tuple = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot;) ~ &quot;)&quot; )

val Parsed.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = tuple.parse(&quot;(1,23)&quot;)

val failure = tuple.parse(&quot;(1,)&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.index == 2,
  failure.extra.traced.trace == &quot;&quot;&quot;tuple:1:1 / (&quot;)&quot; | CharIn(&quot;0123456789&quot;)):1:3 ...&quot;,)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L348-L358" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                in many (but not all!) cases, if a delimiter is parsed, you want to commit to parsing one more iteration of the <a href="#Repeat">Repeat</a>. However, by default, it backtracks out of the <a href="#Repeat">Repeat</a> entirely and starts trying to parse the next item in sequence (in this case the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> giving the behavior shown above.
</p>
            <p>
                With a cut, the error is improved:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P( CharIn('0' to '9').rep(1) )
val tuple = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot; ~/ Pass) ~ &quot;)&quot; )

val Parsed.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = tuple.parse(&quot;(1,23)&quot;)

val failure = tuple.parse(&quot;(1,)&quot;).asInstanceOf[Parsed.Failure]
assert(
  failure.index == 3,
  failure.extra.traced.trace == &quot;&quot;&quot;tuple:1:1 / digits:1:4 / CharIn(&quot;0123456789&quot;):1:4 ...&quot;)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L360-L370" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code> operator can be used without following parser as a shortcut for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/ Pass</code>. Compare the previous example with the following one:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digits = P( CharIn('0' to '9').rep(1) )
val tuple = P( &quot;(&quot; ~ digits.!.rep(sep=&quot;,&quot;.~/) ~ &quot;)&quot; )

val Parsed.Success(Seq(&quot;1&quot;, &quot;23&quot;), _) = tuple.parse(&quot;(1,23)&quot;)

val failure = tuple.parse(&quot;(1,)&quot;).asInstanceOf[Parsed.Failure]
val trace = failure.extra.traced.trace
assert(
  failure.index == 3,
  trace == &quot;&quot;&quot;tuple:1:1 / digits:1:4 / CharIn(&quot;0123456789&quot;):1:4 ...&quot;)&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L372-L383" target="_blank"><i class="fa fa-link "></i></a></pre>

        <h2 id="IsolatingCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#IsolatingCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Isolating Cuts</h2>
            <p>
                Because cuts prevent backtracking throughout the entire parser, they make it difficult to compose arbitrary parsers:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digit = P( CharIn('0' to '9') )
val time1 = P( (&quot;1&quot;.? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit ~ (&quot;am&quot; | &quot;pm&quot;) )
val time2 = P( ((&quot;1&quot; | &quot;2&quot;).? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit )
val Parsed.Success((), _) = time1.parse(&quot;12:30pm&quot;)
val Parsed.Success((), _) = time2.parse(&quot;17:45&quot;)
val time = P( time1 | time2 )
val Parsed.Success((), _) = time.parse(&quot;12:30pm&quot;)
val failure = time.parse(&quot;17:45&quot;).asInstanceOf[Parsed.Failure]
assert(failure.index == 5)  // Expects am or pm</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L385-L394" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                In the above case, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time1</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time2</code> are arbitrary parsers containing <a href="#Cuts">Cuts</a>. By default, that means that once you've crossed a cut, you can no longer backtrack. However, there are cases where you want to use an existing parser (for example <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time1</code>) in a situation where you want to allow it to backtrack, but you don't want to rewrite it identically but without cuts. In this case it's trivial, but if <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">time1</code> was larger you would need to rewrite all of it as well as all of its transitive sub-parsers to make sure that not a single one had a cut inside!
</p>
            <p>
                To explicitly isolate a cut to one branch of a parser, place that branch within <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">NoCut</code>.  Cuts within that branch will prevent backtracking inside that branch, but if that branch fails alternate branches will be tried as normal.
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val digit = P( CharIn('0' to '9') )
val time1 = P( (&quot;1&quot;.? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit ~ (&quot;am&quot; | &quot;pm&quot;) )
val time2 = P( ((&quot;1&quot; | &quot;2&quot;).? ~ digit) ~ &quot;:&quot; ~/ digit ~ digit )
val Parsed.Success((), _) = time1.parse(&quot;12:30pm&quot;)
val Parsed.Success((), _) = time2.parse(&quot;17:45&quot;)
val time = P( NoCut(time1) | time2 )
val Parsed.Success((), _) = time.parse(&quot;12:30pm&quot;)
val Parsed.Success((), _) = time.parse(&quot;17:45&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L396-L404" target="_blank"><i class="fa fa-link "></i></a></pre>
    <h1 id="Unapply" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Unapply" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Unapply</h1>
        <p>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code> class has a convenient method <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">unapply</code>
            which allows to do pattern matching using parsers (like regular
            expressions) in your code.

            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val capture1 = P( &quot;a&quot;.rep.! ~ &quot;b&quot; ~ End)

val Parsed.Success(&quot;aaa&quot;, 4) = capture1.parse(&quot;aaab&quot;)

val capture2 = P( &quot;a&quot;.rep.! ~ &quot;b&quot;.! ~ End)

val Parsed.Success((&quot;aaa&quot;, &quot;b&quot;), 4) = capture2.parse(&quot;aaab&quot;)

val capture3 = P( &quot;a&quot;.rep.! ~ &quot;b&quot;.! ~ &quot;c&quot;.! ~ End)

val Parsed.Success((&quot;aaa&quot;, &quot;b&quot;, &quot;c&quot;), 5) = capture3.parse(&quot;aaabc&quot;)

val captureRep = P( &quot;a&quot;.!.rep ~ &quot;b&quot; ~ End)

val Parsed.Success(Seq(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;), 4) = captureRep.parse(&quot;aaab&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L105-L121" target="_blank"><i class="fa fa-link "></i></a></pre></p>
        <p>
            If the parser succeeds, the return value of the parser is bound
            to the name in the pattern match. If the parser fails, the
            pattern match fails. Note you do not have access to the failure
            details when pattern-matching-syntax/unapply with a parser: if
            you need that, call <code>.parse</code> and pattern match on the
            <a href="#ParsingResults">Parsing Results</a> yourself</p>

    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="StreamingParsing" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Streaming Parsing<a class=" scalatex-site-Styles-headerLink" href="#StreamingParsing" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        In addition to the parsing strings, you can also parse &quot;streaming&quot;
        data from <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Iterator</code>s. To do so, call <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.parseIterator</code>
        instead of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.parse</code> in your parser and pass the
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Iterator[String]</code> (or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Iterator[Array[Byte]]</code> for
        <a href="#ByteParsers">Byte Parsers</a>).
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.all._
val p = P( &quot;ab&quot; ~/ &quot;cd&quot;.rep().! ~ &quot;ef&quot; | &quot;z&quot; )

val Parsed.Success(res, i) = p.parseIterator(
  Iterator(&quot;ab&quot;, &quot;cd&quot;, &quot;cd&quot;, &quot;cd&quot;, &quot;ef&quot;)
)

assert(res == &quot;cdcdcd&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/IteratorTests.scala#L31-L39" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
        Note that fastparse does not parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Iterator[Char]</code> or
        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Iterator[Byte]</code>s for performance reasons: most input
        sources make data available in chunks, such as network packets or
        lines from file on the disk.
        By parsing chunks, FastParse better matches any underlying
        data source, and itself has better performance parsing larger chunks.</p>
    <p>
        Streaming parsing still needs to buffer input in-memory: in particular,
        parsers like <a href="#Optional">Optional</a>, <a href="#Repeat">Repeat</a> or
        <a href="#Either">Either</a> means a parser may backtrack, and thus FastParse
        needs to buffer any input from where such a parsers starts parsing.
        Other parsers like <a href="#Capture">Capture</a> do not backtrack, but need
        to buffer data in order to return the data that gets captured. Using
        <a href="#Cuts">Cuts</a> to prevent backtracking, apart from making
        <a href="#DebuggingParsers">Debugging Parsers</a> easier, also allows FastParse to flush
        parts of the buffer that it no longer needs to backtrack into.
</p>
    <p>
        <i>
            In general every cut in your parser possibly reduces the memory
            used to buffer input for iterator parsing

</i></p>
    <h1 id="StreamingParsingBufferSize" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StreamingParsingBufferSize" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Streaming Parsing Buffer Size</h1>
        <p>
            This first benchmark measures the maximum size of buffered input
            when using streaming parsing, for some sample parsers we have in
            the test suite, for input-chunks of size 1 and 1024:
</p>
        <table style="width: 100%;" class="pure-table">
            <thead>
                <th>Parser</th>
                <th>Maximum buffer <br /> for 1-sized chunk</th>
                <th>Maximum buffer <br /> for 1024-sized chunk</th>
                <th>Size of input</th>
                <th>Used memory</th></thead>
            <tbody>
                <tr>
                    <td>ScalaParse</td><td>1555</td><td>2523</td><td>147894</td><td>1.4%</td></tr>
                <tr>
                    <td>PythonParse</td><td>2006</td><td>2867</td><td>68558</td><td>3.6%</td></tr>
                <tr>
                    <td>BmpParse</td><td>36</td><td>1026</td><td>786486</td><td>0.01%</td></tr>
                <tr>
                    <td>ClassParse</td><td>476</td><td>1371</td><td>332142</td><td>0.3%</td>
</tr></tbody></table>
        <p>
            As you can see, for these &quot;typical&quot; parsers, some input needs to
            be buffered to allow backtracking, but it turns out to be only a
            few percent of the total file size.</p>
        <p>
            These parsers make heavy use of backtracking operators like
            <a href="#Either">Either</a> or <a href="#Repeat">Repeat</a>, but also make
            heavy use of <a href="#Cuts">Cuts</a>. This lets FastParse drop buffered
            input when it knows it can no longer backtrack.</p>
        <p>
            Another thing to note is the chunk size: a smaller chunk size
            reduces the granularity of the chunks that get buffered,
            reducing the buffer size. However, this comes at a performance
            cost, as you can see below...

</p>
    <h1 id="StreamingParsingPerformance" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StreamingParsingPerformance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Streaming Parsing Performance</h1>
        <p>
            This next benchmark measures the effect of streaming parsing on
            runtime performance, using two different chunk-sizes, compared
            to the performance of non-streaming parsing:
</p>
        <table style="width: 100%;" class="pure-table">
            <thead>
                <th>Parser</th>
                <th>Score on the plain parsing</th>
                <th>Score on the iterator parsing <br /> for 1-sized chunk</th>
                <th>Score on the iterator parsing <br /> for 1024-sized chunk</th></thead>
            <tbody>
                <tr>
                    <td>ScalaParse</td><td>43</td><td>33</td><td>43</td></tr>
                <tr>
                    <td>PythonParse</td><td>1150</td><td>600</td><td>890</td></tr>
                <tr>
                    <td>BmpParse</td><td>195</td><td>15</td><td>40</td></tr>
                <tr>
                    <td>ClassParse</td><td>160</td><td>40</td><td>100</td>
</tr></tbody></table>
        <p>
            Here, we can see that streaming parsing has a non-trivial effect
            on performance: ScalaParse seems unaffected by a chunks of size
            1024, and takes a 25% performance hit for chunks of size 1, but
            PythonParse takes a significant hit (25%, 47%) and ClassParse
            and BmpParse have it much worse. While smaller chunk sizes
            results in smaller buffers, it also comes with a performance
            cost. Exactly how big you want your input chunks to be is up to
            you to decide: FastParse will accept an iterator of chunks
            as large or as small as you want.
</p>
        <p>
            In general, Streaming Parsing it always going to be a
            performance hit over parsing a single <code>String</code> you
            pre-loaded in memory. The point of streaming parsing is to
            handle cases where you can't/don't-want-to load everything in
            memory. In that case, if the choice is between slightly-slower
            parsing or an <code>OutOfMemory</code> error, streaming parsing is
            a good option to have.
</p>
    <h1 id="StreamingParsingLimitations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StreamingParsingLimitations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Streaming Parsing Limitations</h1>
        <p>
            Apart from the performance/memory tradeoff mentioned above,
            streaming parsing has some limitations that it is worth being aware of:</p>
        <ul>
            <li>
                Performance of iterator parsing is always going to be
                slower than performance of raw <code>String</code> or <code>Array[Byte]</code>
                parsing: this is unavoidable given the overhead of maintaining
                and trimming the input buffer</li>
            <li>
                Memory use when parsing iterators is always going to depend
                on aggressive use of <a href="#Cuts">Cuts</a> within the parser: most
                real-world parsers rely heavily on <a href="#Optional">Optional</a>,
                <a href="#Repeat">Repeat</a> and <a href="#Either">Either</a>, all of which will
                cause input to be buffered in memory unless you use
                <a href="#Cuts">Cuts</a> to avoid backtracking</li>
            <li>
                You can't use <a href="#Tracing">Tracing</a> after parsing an iterator:
                tracing performs a second parse on the same input to generate
                its error information, and the iterator input gets exhausted after
                the first parsing pass and are not available for a second time.</li>
            <li>
                Streaming parsing does not support parsing
                <code>scala.Stream[String]</code>, as <code>scala.Stream</code> buffers
                everything in memory, making it pretty useless from a
                perspective of &quot;streaming parsing&quot; where you explicitly
                <i>don't</i> want to do that.</li>
            <li>
                Streaming parsing does not (and will likely never) support
                <a href="http://stackoverflow.com/questions/15895124/what-is-push-approach-and-pull-approach-to-parsing">&quot;async&quot; or &quot;push&quot; parsing</a>.
                This is because FastParse's entire execution model is based
                on a straightforward recursive-descent over the input stream.
                It's unlikely we'll ever be able to graft async-parsing
                on top of this execution model.</li></ul>

    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ExampleParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Example Parsers<a class=" scalatex-site-Styles-headerLink" href="#ExampleParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        Above, we've already covered all the individual bits and pieces that make writing a parser possible. But how does that fit together? Let's take a look at some examples.
</p>
    <h1 id="Math" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Math" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Math</h1>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.all._

val number: P[Int] = P( CharIn('0'to'9').rep(1).!.map(_.toInt) )
val parens: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
val factor: P[Int] = P( number | parens )

val divMul: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~/ divMul).rep ).map(eval)
val expr: P[Int]   = P( addSub ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L19-L29" target="_blank"><i class="fa fa-link "></i></a></pre>


        <p>
            This is a small arithmetic expression parser, the same one shown at the top of this page. It parses only whole integers, parentheses, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">+-*/</code>, and no whitespace.</p>
        <p>
            Things to note:
</p>
        <ul>
            <li>
                The various sub-parsers are all of type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Int]</code>, indicating that they result in an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Int</code> if successful. Many of the type annotations could be removed due to type-inference, but they're shown here for clarity</li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">divMul</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">addSub</code> are separated out, in order to properly account for precedence</li>
            <li>
                We evaluate the expression as the parse progresses, meaning we never actually build an tree structure from the input string</li>
            <li>
                In order to convert the parsed strings to integers, we <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">map</code> on the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">eval</code> function, which itself is defined earlier:
</li></ul>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def eval(tree: (Int, Seq[(String, Int)])) = {
  val (base, ops) = tree
  ops.foldLeft(base){ case (left, (op, right)) =&gt; op match{
    case &quot;+&quot; =&gt; left + right case &quot;-&quot; =&gt; left - right
    case &quot;*&quot; =&gt; left * right case &quot;/&quot; =&gt; left / right
  }}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L11-L19" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            This is a small example, but it works. We check it to verify that every parse results in the expected integer:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Success(2, _) = expr.parse(&quot;1+1&quot;)
val Parsed.Success(15, _) = expr.parse(&quot;(1+1*2)+3*4&quot;)
val Parsed.Success(21, _) = expr.parse(&quot;((1+1*2)+(3*4*5))/3&quot;)
val Parsed.Failure(expected, failIndex, extra) = expr.parse(&quot;1+1*&quot;)
assert(expected == (number | parens), failIndex == 4)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L31-L36" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Try it out yourself! Remember that it does not handle whitespace:
</p>
        <div id="mathdiv"></div>
        <script>demo.DemoMain.math(document.getElementById("mathdiv"))</script>
    <h1 id="WhitespaceHandling" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WhitespaceHandling" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Whitespace Handling</h1>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val White = WhitespaceApi.Wrapper{
  import fastparse.all._
  NoTrace(&quot; &quot;.rep)
}
import fastparse.noApi._
import White._
def eval(tree: (Int, Seq[(String, Int)])): Int = {
  val (base, ops) = tree
  ops.foldLeft(base){ case (left, (op, right)) =&gt; op match{
    case &quot;+&quot; =&gt; left + right case &quot;-&quot; =&gt; left - right
    case &quot;*&quot; =&gt; left * right case &quot;/&quot; =&gt; left / right
  }}
}
val number: P[Int] = P( CharIn('0'to'9').rep(1).!.map(_.toInt) )
val parens: P[Int] = P( &quot;(&quot; ~/ addSub ~ &quot;)&quot; )
val factor: P[Int] = P( number | parens )

val divMul: P[Int] = P( factor ~ (CharIn(&quot;*/&quot;).! ~/ factor).rep ).map(eval)
val addSub: P[Int] = P( divMul ~ (CharIn(&quot;+-&quot;).! ~/ divMul).rep ).map(eval)
val expr: P[Int]   = P( &quot; &quot;.rep ~ addSub ~ &quot; &quot;.rep ~ End )</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/WhiteSpaceMathTests.scala#L9-L30" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            To handle whitespace and other non-significant characters with FastParse, use the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">WhitespaceApi</code> as a substitue for the normal API that is provided for parsers. This modifies the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> operators to consume all non-trailing whitespace and ignoring it.
</p>
        <p>
            Note how you can pass in whatever definition of whitespace you want: here we're passing in a simple <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot; &quot;.rep</code>, but in a more sophisticated parser you may wish to include tabs, newlines, comments or even nested comments. The whitespace parser can be arbitrarily complex.
</p>
        <p>
            Note also how we're importing from <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.noApi</code> instead of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.all</code>, and then substituting it with our one whitespace-consuming parser API. Other than that, the parser is identical except for added whitespace parsers at the start and end of the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> rule.
</p>
        <p>
            Here it is in action:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def check(str: String, num: Int) = {
  val Parsed.Success(value, _) = expr.parse(str)
  assert(value == num)
}

* - check(&quot;1+1&quot;, 2)
* - check(&quot;1+   1*   2&quot;, 3)
* - check(&quot;(1+   1  *  2)+(   3*4*5)&quot;, 63)
* - check(&quot;15/3&quot;, 5)
* - check(&quot;63  /3&quot;, 21)
* - check(&quot;(1+    1*2)+(3      *4*5)/20&quot;, 6)
* - check(&quot;((1+      1*2)+(3*4*5))/3&quot;, 21)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/WhiteSpaceMathTests.scala#L32-L44" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Or try it yourself:
</p>
        <div id="wsmathdiv"></div>
        <script>demo.DemoMain.whitespaceMath(document.getElementById("wsmathdiv"))</script>

    <h1 id="IndentationGrammars" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#IndentationGrammars" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Indentation Grammars</h1>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def eval(tree: (String, Seq[Int])) = tree match{
  case (&quot;+&quot;, nums) =&gt; nums.reduceLeft(_+_)
  case (&quot;-&quot;, nums) =&gt; nums.reduceLeft(_-_)
  case (&quot;*&quot;, nums) =&gt; nums.reduceLeft(_*_)
  case (&quot;/&quot;, nums) =&gt; nums.reduceLeft(_/_)
}

/**
 * Parser for an indentation-based math syntax. Parens are no longer
 * necessary, and the whole parser is parametrized with the current
 * depth of indentation
 */
class Parser(indent: Int){
  val number: P[Int] = P( CharIn('0'to'9').rep(1).!.map(_.toInt) )

  val deeper: P[Int] = P( &quot; &quot;.rep(indent + 1).!.map(_.length) )
  val blockBody: P[Seq[Int]] = &quot;\n&quot; ~ deeper.flatMap(i =&gt;
    new Parser(indent = i).factor.rep(1, sep = (&quot;\n&quot; + &quot; &quot; * i).~/)
  )
  val block: P[Int] = P( CharIn(&quot;+-*/&quot;).! ~/ blockBody).map(eval)

  val factor: P[Int] = P( number | block )

  val expr: P[Int]   = P( block ~ End )
}
val expr = new Parser(indent = 0).expr</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/IndentationTests.scala#L8-L34" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
            Here is a grammar that is used to parse a simple indentation-based math grammar. To understand the grammar it is trying to parse, it is worth looking at the test data:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def check(str: String, num: Int) = {
  val Parsed.Success(value, _) = expr.parse(str)
  assert(value == num)
}

check(
  &quot;&quot;&quot;+
    |  1
    |  1
  &quot;&quot;&quot;.stripMargin.trim,
  2
)
check(
  &quot;&quot;&quot;+
    |  1
    |  *
    |    1
    |    2
  &quot;&quot;&quot;.stripMargin.trim,
  3
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/IndentationTests.scala#L36-L58" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            As you can see, it is basically a prefix math evaluator, where you use indentation to pass the numbers or expressions to each operator to operate on.
</p>
        <p>
            As for the parser, the novel things are:
</p>
        <ul>
            <li>
                All the rules live in a class parametrized on the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">indent</code> that is currently in place</li>
            <li>
                At each level, the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">factor</code>s (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">number</code>s or further <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">block</code>s) inside a block are separated by a newline and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">indent</code> spaces</li>
            <li>
                The initial top-level <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> rule starts off with indentation <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">0</code></li>
            <li>
                After parsing an operator, we use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">deeper</code> to figure out how deep the first line of the indented block is.</li>
            <li>
                We then use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.flatMap</code> to increment the indentation to the new value and parse the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">factor</code>s at that indentation.
</li></ul>
        <p>
            Note how there is no pre-processing, and no lexining phase where the lexer has to guess where in the token stream to inject synthetic indent and dedent tokens, Everything happens in a single pass.</p>
        <p>
            Try it out!</p>
        <div id="indentdiv"></div>
        <script>demo.DemoMain.indentation(document.getElementById("indentdiv"))</script>

    <h1 id="Json" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Json" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Json</h1>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// Here is the parser
val StringChars = NamedFunction(!&quot;\&quot;\\&quot;.contains(_: Char), &quot;StringChars&quot;)

val space         = P( CharsWhileIn(&quot; \r\n&quot;).? )
val digits        = P( CharsWhileIn(&quot;0123456789&quot;))
val exponent      = P( CharIn(&quot;eE&quot;) ~ CharIn(&quot;+-&quot;).? ~ digits )
val fractional    = P( &quot;.&quot; ~ digits )
val integral      = P( &quot;0&quot; | CharIn('1' to '9') ~ digits.? )

val number = P( CharIn(&quot;+-&quot;).? ~ integral ~ fractional.? ~ exponent.? ).!.map(
  x =&gt; Js.Num(x.toDouble)
)

val `null`        = P( &quot;null&quot; ).map(_ =&gt; Js.Null)
val `false`       = P( &quot;false&quot; ).map(_ =&gt; Js.False)
val `true`        = P( &quot;true&quot; ).map(_ =&gt; Js.True)

val hexDigit      = P( CharIn('0'to'9', 'a'to'f', 'A'to'F') )
val unicodeEscape = P( &quot;u&quot; ~ hexDigit ~ hexDigit ~ hexDigit ~ hexDigit )
val escape        = P( &quot;\\&quot; ~ (CharIn(&quot;\&quot;/\\bfnrt&quot;) | unicodeEscape) )

val strChars = P( CharsWhile(StringChars) )
val string =
  P( space ~ &quot;\&quot;&quot; ~/ (strChars | escape).rep.! ~ &quot;\&quot;&quot;).map(Js.Str)

val array =
  P( &quot;[&quot; ~/ jsonExpr.rep(sep=&quot;,&quot;.~/) ~ space ~ &quot;]&quot;).map(Js.Arr(_:_*))

val pair = P( string.map(_.value) ~/ &quot;:&quot; ~/ jsonExpr )

val obj =
  P( &quot;{&quot; ~/ pair.rep(sep=&quot;,&quot;.~/) ~ space ~ &quot;}&quot;).map(Js.Obj(_:_*))

val jsonExpr: P[Js.Val] = P(
  space ~ (obj | array | string | `true` | `false` | `null` | number) ~ space
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L41-L78" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            This is a somewhat larger example than the math parser shown above. In it, we parse a JSON expression from a string, including all the proper handling for whitespace and error-handling built in.
</p>
        <p>
            Things to note:
</p>
        <ul>
            <li>
                We use cuts (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code>) liberally in order to improve the quality of errors. Anywhere there's an <a href="#Either">Either</a> or <a href="#Repeat">Repeat</a>, the children have cuts once the parse has progressed far enough backtracking isn't an option.</li>
            <li>
                We use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharIn</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> quite a lot, in order to speed up the common case of consuming lots of boring characters.</li>
            <li>
                In <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">strChars</code>, we break out of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> closing quote (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">'&quot;'</code>) or whenever we see the start of an escape sequence (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">'\'</code>). Although <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> can't process these multi-char sequences, we let the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">escape</code> parser deal with these before trying to fall back to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">strChars</code> after. This lets us speed up the &quot;common&quot; case of consuming large numbers of non-escape characters, while still properly handling escapes.</li>
            <li>
                We use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.map</code> to convert the various things we parse into instances of our own <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Js.Val</code> JSON AST:

</li></ul>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Js {
  sealed trait Val extends Any {
    def value: Any
    def apply(i: Int): Val = this.asInstanceOf[Arr].value(i)
    def apply(s: java.lang.String): Val =
      this.asInstanceOf[Obj].value.find(_._1 == s).get._2
  }
  case class Str(value: java.lang.String) extends AnyVal with Val
  case class Obj(value: (java.lang.String, Val)*) extends AnyVal with Val
  case class Arr(value: Val*) extends AnyVal with Val
  case class Num(value: Double) extends AnyVal with Val
  case object False extends Val{
    def value = false
  }
  case object True extends Val{
    def value = true
  }
  case object Null extends Val{
    def value = null
  }
}

case class NamedFunction[T, V](f: T =&gt; V, name: String) extends (T =&gt; V){
  def apply(t: T) = f(t)
  override def toString() = name

}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L14-L41" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            We can verify that this parser builds the JSON tree that we expect:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Success(value, _) = jsonExpr.parse(
  &quot;&quot;&quot;{&quot;omg&quot;: &quot;123&quot;, &quot;wtf&quot;: 12.4123}&quot;&quot;&quot;
)
assert(value == Js.Obj(&quot;omg&quot; -&gt; Js.Str(&quot;123&quot;), &quot;wtf&quot; -&gt; Js.Num(12.4123)))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L94-L98" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            And that it provides good error messages in the case of mal-formed JSON, even for moderately-sized fragemnts
</p>
        
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">{
    &quot;firstName&quot;: &quot;John&quot;,
    &quot;lastName&quot;: &quot;Smith&quot;,
    &quot;age&quot;: 25,
    &quot;address&quot;: {
        &quot;streetAddress&quot;: &quot;21 2nd Street&quot;,
        &quot;city&quot;: &quot;New York&quot;,
        &quot;state&quot;: &quot;NY&quot;,
        &quot;postalCode&quot;: 10021
    },
    &quot;phoneNumbers&quot;:
        {
            &quot;type&quot;: &quot;home&quot;,
            &quot;number&quot;: &quot;212 555-1234&quot;
        },
        {
            &quot;type&quot;: &quot;fax&quot;,
            &quot;number&quot;: &quot;646 555-4567&quot;
        }
    ]
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L299-L320" target="_blank"><i class="fa fa-link "></i></a></pre>

        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">jsonExpr:1:1 / obj:2:9 / pair:16:19 / string:16:19 / &quot;\&quot;&quot;:17:17 ...&quot;{\n        &quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/JsonTests.scala#L322-L323" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Here, we're missing a square bracket after the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;phoneNumbers&quot;</code> key, and so the parser expects to find a single JSON expression. It finds a JSON object, and then fails reporting that it expected to find the next key (a string), but instead found <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;{\n&quot;</code> at that index.
</p>
        <p>
            Try it out!
</p>
        <div id="jsondiv"></div>
        <script>demo.DemoMain.json(document.getElementById("jsondiv"))</script>

    <h1 id="ScalaParse" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ScalaParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>ScalaParse</h1>

        <div id="scaladiv"></div>
        <script>demo.DemoMain.scalaparser(document.getElementById("scaladiv"))</script>

        <p>
            ScalaParse is a parser for the entire Scala programming language, written using FastParse. This is notable for a few reasons:
</p>
        <ul>
            <li>
                ScalaParse is about 700 lines of code, making it about 1/10th the size of the default parser in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">tools.nsc.Global</code></li>
            <li>
                ScalaParse runs about <a href="#Performance">1/8th the speed</a> of of the default parser in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">tools.nsc.Global</code></li>
            <li>
                ScalaParse has excellent error reporting due to proper use of <a href="#Cuts">Cuts</a>, without any code explicitly dedicated to error reporting</li></ul>
        <p>
            ScalaParse does not currently generate an AST. As you can see, the parse result above is listed as <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">undefined</code>. However, that does not make it useless! Even without generating an AST, ScalaParse can be used to:
</p>
        <ul>
            <li>
                Check for errors! ScalaParse provides excellent error reporting on parses, equal or better than that provided by the tools.nsc.Global parser, entirely for free.</li>
            <li>
                Prototype extensions to the Scala grammar! Unlike the default tools.nsc.Global parser, ScalaParse makes it trivial to add new rules at various sections of the grammar.</li>
            <li>
                Manipulate Scala code sections! It's trivial to wrap various rules in ScalaParse in an <a href="#Capture">Capture</a> and use it to pull out the relevant bits of a Scala file for you to use.

</li></ul>
        <h2 id="UsingScalaParse" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UsingScalaParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Using ScalaParse</h2>
            <p></p>
            To begin using ScalaParse, add

            <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %% &quot;scalaparse&quot; % &quot;0.4.4&quot;
</code></pre>
            <p>
                To your SBT configuration. To use with Scala.js, you'll need
</p>
            <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;scalaparse&quot; % &quot;0.4.4&quot;
</code></pre>
    <h1 id="PythonParse" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#PythonParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>PythonParse</h1>
        <p>
            There is now an <a href="https://github.com/lihaoyi/fastparse/tree/master/pythonparse/shared/src/main/scala/pythonparse">example Python parser</a> available under a subproject in the repo. This is a good example of a real-world parser: parsing knotty syntax (including indentation-delimited blocks!), building an AST, and with heavy unit tests.
</p>
        <p>
            PythonParse is currently compatible enough to parse all the python sources in Zulip, Ansible, Changes, Django, and Flask. It isn't published yet on maven central, but feel free to look at it if you want an idea of how to write a complex, real parser.
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;pythonparse&quot; % &quot;0.4.4&quot;
</code></pre>
    <h1 id="CssParse" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CssParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>CssParse</h1>
        <p>
            CssParse is a parser that parses CSS files into an abstract syntax tree (AST).
            The implementation is too large to show in-line, but can be found here:</p>
        <ul>
            <li>
                <a href="https://github.com/lihaoyi/fastparse/tree/master/cssparse/shared/src/main/scala/cssparse">CssParse</a>
</li></ul>
        <p>
            This AST can then be used for a variety of reasons: you could
            analyze the CSS to try and find bugs, transform the CSS in some
            custom way (e.g. prefixing class-names with the name of the file)
            or just re-formatting the CSS when printing it back out.</p>
        <p>
            CssParse compiles to Javascript via Scala.js, and we have a demo
            here that demonstrates the use of CssParse as a CSS pretty-printer.
            Enter some CSS in the box below, no matter how it's formatted or
            minified, and CssParse will add the necessary spaces and tabs to make
            the file readable and good-looking.
</p>
        <div id="cssdiv"></div>
        <script>demo.DemoMain.css(document.getElementById("cssdiv"))</script>

        <p>
            As mentioned above, CssParse builds and AST that stores
            information about tags and rules in the given CSS, this AST isn't
            complete, because of complexity of initial CSS format,
            but it provides all the essential information about basic elements
            of file (blocks, selectors, rules). The correctness of CssParse is
            tested by parsing and then printing several huge files including CSS
            from Bootstrap and Primer.
</p>
        <p>
            This is available on Maven Central as
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;cssparse&quot; % &quot;0.4.4&quot;</code></pre>


    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="APIHighlights" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">API Highlights<a class=" scalatex-site-Styles-headerLink" href="#APIHighlights" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>

    <h1 id="Parser" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Parser" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Parser</h1>
        <p>
            Fastparse revolves around <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>s objects:
            a parser that can attempt to parse a value <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code> from an input sequence of elements of type <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Elem</code>.
            The <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Repr</code> type-parameter is responsible for output type in <a href="#Capture">Capture</a>,
            since input is converted to the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">IndexedSeq[Elem]</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Iterator[IndexedSeq[Elem]]</code>
            during all parsing operations.
</p>
        <p>
            There are two main cases: for string parser, you are looking at
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T, Char, String]</code>. For <a href="#ByteParsers">Byte Parsers</a>,
            you would be dealing with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T, Byte, Bytes]</code></p>
        <p>
            These are defined as:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">/**
 * A single, self-contained, immutable parser. The primary method is
 * `parse`, which returns a [[T]] on success and a stack trace on failure.
 *
 * Some small optimizations are performed in-line: collapsing
 * [[parsers.Combinators.Either]] cells into large ones and collapsing
 * [[parsers.Combinators.Sequence]] cells into
 * [[parsers.Combinators.Sequence.Flat]]s. These optimizations together appear
 * to make things faster but any 10%, whether or not you activate tracing.
 */
abstract class Parser[+T, Elem, Repr]()(implicit val reprOps: ReprOps[Elem, Repr])
  extends ParserResults[T, Elem, Repr] with Precedence{

  /**
    * Can be passed into a `.parse` call to let you inject logic around
    * the parsing of top-level parsers, e.g. for logging and debugging.
    */
  type InstrumentCallback = (
    (Parser[_, Elem, Repr], Int, () =&gt; Parsed[_, Elem, Repr]) =&gt; Unit
  )

  /**
   * Parses the given `input` starting from the given `index`
   *
   * @param input The string we want to parse
   *
   * @param index The index in the string to start from. By default parsing
   *              starts from the beginning of a string, but you can start
   *              from halfway through the string if you want.
   *
   * @param instrument Allows you to pass in a callback that will get called
   *                   by every named rule, its index, as it itself given a
   *                   callback that can be used to recurse into the parse and
   *                   return the result. Very useful for extracting auxiliary
   *                   information from the parse, e.g. counting rule
   *                   invocations to locate bottlenecks or unwanted
   *                   backtracking in the parser.
   */
  def parse(input: Repr,
            index: Int = 0,
            instrument: InstrumentCallback = null)
      : Parsed[T, Elem, Repr] = {
    parseInput(IndexedParserInput(input), index, instrument)
  }

  def parseIterator(input: Iterator[Repr],
                    index: Int = 0,
                    instrument: InstrumentCallback = null)
                   (implicit ct: ClassTag[Elem])
      : Parsed[T, Elem, Repr] = {
    parseInput(IteratorParserInput(input), index, instrument)
  }

  def parseInput(input: ParserInput[Elem, Repr],
                 index: Int = 0,
                 instrument: InstrumentCallback = null)

      : Parsed[T, Elem, Repr] = {
    parseRec(
      new ParseCtx(input, 0, -1, this, index, instrument, false, false, false),
      index
    ).toResult
  }

  /**
   * Extractor for pattern matching
   *
   *  For example:
   *
   *  {{{
   *  val p1 = CharIn('a'to'z').! ~ CharIn('0'to'9').rep(1).!.map(_.toInt)
   *  List(&quot;a42x&quot;) match {
   *    case p1(x: String, y: Int) :: _ =&gt; // x is &quot;a&quot;, y is 42
   *  }
   * }}}
   */
  def unapply(input: Repr): Option[T] = {
    parse(input) match {
      case Parsed.Success(r, _) =&gt; Some(r)
      case _ =&gt; None
    }
  }

  /**
   * Parses the given `input` starting from the given `index` and `logDepth`
   */
  def parseRec(cfg: ParseCtx[Elem, Repr], index: Int): Mutable[T, Elem, Repr]

  /**
   * Whether or not this parser should show up when
   * [[Parsed.TracedFailure.trace]] is called. If not set, the parser will
    * only show up in [[Parsed.TracedFailure.fullStack]]
   */
  def shortTraced: Boolean = false

  /**
   * Whether or not to surround this parser with parentheses when printing.
   * By default a top-level parser is always left without parentheses, but
   * if a sub-parser is embedded inside with lower precedence, it will be
   * surrounded. Set to `Integer.MaxValue` to never be parenthesized
   */
  def opPred: Int = Precedence.Max
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L315-L418" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Typically, you will be dealing with the aliased version of
            this inside <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.all._</code>:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">type Parsed[+T] = core.Parsed[T, String]
type Parser[+T] = core.Parser[T, Char, String]</code></pre>
        <p>
            Or if you're writing <a href="#ByteParsers">Byte Parsers</a>:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">type Parsed[+T] = core.Parsed[T, Array[Byte]]
type Parser[+T] = core.Parser[T, Byte, Array[Byte]]
</code></pre>
        <p>
            The main external API is <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.parse</code> for parsing regular arrays of data
            and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.parseIterator</code> for parsing streaming data. (<i>See also <a href="#StreamingParsing">Streaming Parsing</a></i>).
            As you can see, apart from the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">input</code> parameter,
            there are a few parameters that you can use to configure the parse.
            Apart from that, each <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T, Elem, Repr]</code> needs
            to implement <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">parseRec</code> which is a less-convenient but
            more-performant version that FastParse uses internally when
            performing a parse.
</p>
        <p>
            This class also supports an <a href="#Unapply">Unapply</a> method, which can
            be used in Scala <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">match</code> expressions.
</p>
        <p>
            Although the core of <a href="#Parser">Parser</a> is simple,
            a lot of additional functionality is included in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ParserApi[T, Elem, Repr]</code> trait
            in order to make constructing parsers convenient and concise.
</p>
    <h1 id="ParserApi" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ParserApi" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>ParserApi</h1>
        <p>
            Apart from the core <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>,
            FastParse includes a large set of operations that you can perform on a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>
            to make composing them more pleasant.
            These all live in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ParserApi</code>:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">abstract class ParserApi[+T, Elem, Repr]()(implicit repr: ReprOps[Elem, Repr]) {

  /**
   * Wraps this in a [[Logged]]. This prints out information
   * where a parser was tried and its result, which is useful for debugging
   */
  def log(msg: String = toString)(implicit out: Logger): Parser[T, Elem, Repr]

  /**
   * Makes this parser opaque, i.e. hides it and its inner parsers
   * from the stack trace, providing the specified message instead.
   */
  def opaque(msg: String = toString): Parser[T, Elem, Repr]

  /**
   * Repeats this parser 0 or more times
   */
  def rep[R](implicit ev: Repeater[T, R]): Parser[R, Elem, Repr]
  def rep[R](min: Int = 0,
             sep: Parser[_, Elem, Repr] = Pass[Elem, Repr],
             max: Int = Int.MaxValue,
             exactly: Int = -1)
            (implicit ev: Repeater[T, R]): Parser[R, Elem, Repr]

  /**
   * Parses using this or the parser `p`
   */
  def |[V &gt;: T](p: Parser[V, Elem, Repr]): Parser[V, Elem, Repr]

  /**
   * Parses using this followed by the parser `p`
   */
  def ~[V, R](p: Parser[V, Elem, Repr])
             (implicit ev: Sequencer[T, V, R]): Parser[R, Elem, Repr]

  /**
   * Parses using this followed by the parser `p`, performing a Cut if
   * this parses successfully. That means that if `p` fails to parse, the
   * parse will fail immediately and not backtrack past this success.
   *
   * This lets you greatly narrow the error position by avoiding unwanted
   * backtracking.
   */
  def ~/[V, R](p: Parser[V, Elem, Repr])
              (implicit ev: Sequencer[T, V, R]): Parser[R, Elem, Repr]

  /**
   * Performs a cut if this parses successfully.
   */
  def ~/ : Parser[T, Elem, Repr]

  /**
   * Parses this, optionally
   */
  def ?[R](implicit ev: Optioner[T, R]): Parser[R, Elem, Repr]

  /**
   * Wraps this in a [[Not]] for negative lookaheak
   */
  def unary_! : Parser[Unit, Elem, Repr]

  /**
   * Used to capture the text parsed by this as a `String`
   */
  def ! : Parser[Repr, Elem, Repr]

  /**
   * Transforms the result of this Parser with the given function
   */
  def map[V](f: T =&gt; V): Parser[V, Elem, Repr]

  /**
   * Uses the result of this parser to create another parser that
   * will be used for the next parse
   */
  def flatMap[V](f: T =&gt; Parser[V, Elem, Repr]): Parser[V, Elem, Repr]

  /**
   * applies the supplied predicate to the current parser succeeding
     on true failing on false
   */
  def filter(predicate: T =&gt; Boolean): Parser[T, Elem, Repr]

  /**
   * alias for `filter`
   */
  final def withFilter(predicate: T =&gt; Boolean): Parser[T, Elem, Repr] = filter(predicate)
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/ParserApi.scala#L8-L97" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            There are essentially all short-hand constructors for the parsers in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">object Parser</code> companion.
            This is the list of operators that you have available when writing your own parsers using FastParse.</p>
        <p>
            As mentioned in <a href="#WhitespaceHandling">Whitespace Handling</a>,
            you can choose to ignore the default set of operators by using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.noApi</code>
            instead of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.all</code>. That way you can use your own set of operators,
            e.g. the whitespace-sensitive operators described in that section.
</p>
    <h1 id="ParsingResults" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ParsingResults" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Parsing Results</h1>
        <p>
            The result of a parser comes in two flavors of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>;
            the first is a success (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code>) and the second is a failure (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code>).
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Success</code> provides the parsed value -
            the value you are probably most interested in -
            and the index in the input string till where the parse was performed.
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code> allows you to retrieve the last parser that failed and the index where it failed.
            Additionally, failure provides an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure.extra</code> field that provides precise details about the failure,
            in particular,
            and most importantly a complete stack trace of the involved parsers, which is accessible via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">extra.traced</code>.
</p>
        <p>
            The recommended method for dealing with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code> is to use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fold</code> which accepts two callbacks.
            The first callback deals with a failed parse attempt and has a type signature of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(Parser[_], Int, Failure.Extra) =&gt; X</code>.
            Each input parameter corresponds to what is available in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Failure</code>.
            The second callback deals with a successful parsing and has type signature <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(T, Int) =&gt; X</code> where <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code> is the parsed result
            and the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Int</code> is the index of the string where the parsing was performed.
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">sealed trait AndOr
case object And extends AndOr
case object Or extends AndOr
val and = P(IgnoreCase(&quot;And&quot;)).map(_ =&gt; And)
val or = P(IgnoreCase(&quot;Or&quot;)).map(_ =&gt; Or)
val andOr = P(and | or)

def check(input: String, expectedOutput: String) =
  assert(andOr.parse(input).fold((_, _, _) =&gt; s&quot;Cannot parse $input as an AndOr&quot;, (v, _) =&gt; s&quot;Parsed: $v&quot;) == expectedOutput)

check(&quot;AnD&quot;, &quot;Parsed: And&quot;)
check(&quot;oR&quot;, &quot;Parsed: Or&quot;)
check(&quot;IllegalBooleanOperation&quot;, &quot;Cannot parse IllegalBooleanOperation as an AndOr&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L478-L491" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            It is also possible to pattern match over <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>, however, you may experience spurious warnings related to <a href="https://issues.scala-lang.org/browse/SI-4440">SI-4440</a>.
            In order to prevent these warnings <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.core.Result</code> in versions 0.2.x and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.core.Parsed</code> in higher versions than 0.2.x.
</p>
        <p>
            An overview of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">/**
 * @param value The result of this parse
 * @param index The index where the parse completed; may be less than
 *              the length of input
 */
case class Success[+T, Elem, Repr](value: T, index: Int) extends Parsed[T, Elem, Repr]</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L55-L62" target="_blank"><i class="fa fa-link "></i></a></pre>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">/**
 * Simple information about a parse failure. Also contains the original parse
 * information necessary to construct the traced failure. That contains more
 * information but is more costly to compute and is thus computed lazily on
 * demand.
 *
 * @param index The index in the parse where this parse failed
 * @param lastParser The deepest parser in the parse which failed
 * @param extra Extra supplementary information (including trace information).
 *              For details see [[Parsed.Failure.Extra]]
 */
case class Failure[Elem, Repr](lastParser: Parser[_, Elem, Repr],
                               index: Int,
                               extra: Failure.Extra[Elem, Repr]) extends Parsed[Nothing, Elem, Repr]{

  def msg = Failure.formatStackTrace(
    Nil, extra.input, index, Failure.formatParser(lastParser, extra.input, index)
  )

  override def toString = s&quot;Failure($msg)&quot;
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L62-L84" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Note how <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code> only contains the parser which failed and a single index where the parse failed.
            Further debugging information is available via the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure.Extra</code> class.
            Especially the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">TracedFailure</code> that is lazily-computed via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Extra.traced</code>,
            provides valuable information: It performs a whole new parse on the input data with additional instrumentation,
            and provides additional insight into why the parse failed:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">/**
 * A failure containing detailed information about a parse failure. This is more
 * expensive to compute than a simple error message and is thus not generated
 * by default.
 *
 * @param fullStack The entire stack trace where the parse failed, containing every
 *                  parser in the stack and the index where the parser was used, excluding
 *                  the final parser and index where the parse failed. Only set if
 *                  `parse` is called with `trace = true`, otherwise empty
 * @param traceParsers A list of parsers that could have succeeded at the location
 *                     that this
 */
case class TracedFailure[Elem, Repr](input: ParserInput[Elem, Repr],
                                     index: Int,
                                     fullStack: Vector[Frame],
                                     traceParsers: Set[Parser[_, Elem, Repr]]) {

  private[this] lazy val expected0 = new Precedence {
    def opPred = if (traceParsers.size == 1) traceParsers.head.opPred else Precedence.|
    override def toString = traceParsers.map(opWrap).mkString(&quot; | &quot;)
  }

  /**
   * A short string describing the parsers which were expected at the point
   * of failure.
   */
  def expected = expected0.toString

  /**
   * A slimmed down version of [[fullStack]], this only includes named
   * [[parsers.Combinators.Rule]] objects as well as the final Parser (whether named or not)
   * and index where the parse failed for easier reading.
   */
  lazy val stack = Failure.filterFullStack(fullStack)

  /**
   * A one-line snippet that tells you what the state of the parser was
   * when it failed. This message is completely derived from other values
   * available on this object, so feel free to use the data yourself if
   * the default error message isn't to your liking.
   */
  lazy val trace = {
    Failure.formatStackTrace(stack, input, index, Failure.formatParser(expected0, input, index))
  }
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/main/scala/fastparse/core/Parsing.scala#L135-L180" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
            Computing the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Extra.traced</code> data is not done by default for performance reasons:
            the additional run takes about 3x longer than the initial run due to the instrumentation,
            for a total of 4x slowdown. If you want the information for debugging, though, it will be there.</p>


    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ByteParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Byte Parsers<a class=" scalatex-site-Styles-headerLink" href="#ByteParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        While FastParse was originally designed to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">String</code>s,
        it also provides a <code>fastparse.byte</code> package that allows parsing
        of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Bytes</code> (or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Iterator[Bytes]</code>s) into
        structured data.</p>
    <p>
        To begin using FastParse to parse bytes, add
</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %% &quot;fastparse-byte&quot; % &quot;0.4.4&quot;
</code></pre>
    <p>
        To your SBT configuration. To use with Scala.js, you'll need</p>
    <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;fastparse-byte&quot; % &quot;0.4.4&quot;
</code></pre>
    <p>
        Here is a small example parser that parsers an imaginary struct-like
        format: a fixed header, two fixed-length fields (big-endian), one
        <a href="https://en.wikipedia.org/wiki/String_(computer_science)#Null-terminated">0-terminated C-style string</a>,
        and one <a href="https://en.wikipedia.org/wiki/String_(computer_science)#Length-prefixed">length-prefixed</a>
        binary blob up to 65535 bytes
        long (the max size of the UInt16 length field):

</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

case class Struct(f: Float, i: Int, s: String, b: Bytes)

val header = P( BS(0xDE, 0xAD, 0xBE, 0xEF) ~ BE.Float32 ~ BE.Int32 )

val cString = P( BytesWhile(_ != 0).! ~ BS(0x0) ).map(x =&gt; new String(x.toArray))

val varLengthBlob = BE.UInt16.flatMap{AnyBytes(_).!}

val structThing = P( header ~ cString ~ varLengthBlob ~ End).map(Struct.tupled)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L516-L528" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
        As you can see it has the same underlying structure as previous
        <a href="#Basic">Basic</a> string-parsers: it uses <code>~</code> to <a href="#Sequence">Sequence</a>
        parsers, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">!</code> to <a href="#Capture">Capture</a> sections of bytes,
        <a href="#Map">Map</a>, to turn them into useful structures, etc..
</p>
    <p>
        Here is how we use it:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val bytes = Bytes(
  0xDE, 0xAD, 0xBE, 0xEF,
  64, 73, 15, -37,
  0, 0, 122, 105,
  104, 101, 108, 108, 111, 0,
  0, 5, 119, 111, 114, 108, 100
)

val Parsed.Success(result, _) = structThing.parse(bytes)


assert(
  math.abs(result.f - Math.PI) &lt; 0.0001,
  result.i == 31337,
  result.s == &quot;hello&quot;,
  new String(result.b.toArray) == &quot;world&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L528-L546" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
        About the same as what you would expect, if you had used FastParse
        to parse textual Strings.
</p>
    <p>
        While <code>fastparse.byte</code> is similar to the string-parsing
        API, there are some new primitives that are specific to byte parsers,
        and some existing primitives that are named slightly differently.
</p>
    <h1 id="Bytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Bytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Bytes</h1>
        <p>
            The primary data-structure <code>fastparse.byte</code> works with is
            <code>Bytes</code>. This gets imported when you
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.byte.all._</code>, and is an alias for the
            excellent <code>scodec.bits.ByteVector</code> class from
            <a href="https://github.com/scodec/scodec-bits">scodec-bits</a> by
            <a href="https://www.github.com/mpilquist">Michael Pilquist</a>.
            <code>Bytes</code> is basically an immutable version of
            <code>Array[Byte]</code>, with structural equality, a useful
            <code>toString</code>, and convenient operations for all the things you
            typically want to do with blobs of bytes. <code>fastparse.byte</code>'s
            <code>.parse</code> method takes <code>Bytes</code> as input, and its
            <a href="#Capture">Capture</a> operator captures <code>Bytes</code> as output.
</p>
        <p>
            <code>Bytes</code> provides convenient methods for construction:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

// Constructing a short ByteVector from bytes
val a = Bytes(0x01, 0xff)
assert(a.toString == &quot;ByteVector(2 bytes, 0x01ff)&quot;)

// Constructing a ByteVector from an ASCII string
val b  = Bytes(&quot;hello&quot;:_*)
assert(b.toString == &quot;ByteVector(5 bytes, 0x68656c6c6f)&quot;)

// Constructing a ByteVector copying from a Array[Byte]
val byteArray = Array[Byte](1, 2, 3, 4)
val c = Bytes(byteArray)
assert(c.toString == &quot;ByteVector(4 bytes, 0x01020304)&quot;)

// Unsafe construction from an Array[Byte], without copying; assumes
// You do not mutate the underlying array, otherwise things break.
val d = Bytes.view(byteArray)
assert(d.toString == &quot;ByteVector(4 bytes, 0x01020304)&quot;)

// Hex Strings
val e = hex&quot;cafebabedeadbeef&quot;
assert(e.toString == &quot;ByteVector(8 bytes, 0xcafebabedeadbeef)&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L359-L382" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            <code>Bytes</code> provides many of the common operations that you would
            want to perform on binary-blobs build in. These more or less match
            what you would expect from the standard Scala collections:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val a = Bytes(0xff, 0xff)
val b = Bytes(0x01, 0x01)

// Simple operations
assert(
  a.length == 2,
  a(0) == 0xff.toByte,
  b(0) == 0x01.toByte
)

// Concatenating byte vectors
val c = a ++ b
assert(c.toString == &quot;ByteVector(4 bytes, 0xffff0101)&quot;)

val d = b ++ a
assert(d.toString == &quot;ByteVector(4 bytes, 0x0101ffff)&quot;)

// Converting to Arrays
val arr = d.toArray
assert(
  arr(0) == 1, arr(1) == 1,
  arr(2) == -1, arr(3) == -1
)


// Convenient conversions
assert(
  c.toHex == &quot;ffff0101&quot;,
  c.toBase64 == &quot;//8BAQ==&quot;,
  Bytes.fromHex(&quot;ffff0101&quot;).get == c,
  Bytes.fromHex(&quot;&quot;&quot;
    ff ff
    01 01
  &quot;&quot;&quot;).get == c,
  Bytes.fromBase64(&quot;//8BAQ==&quot;).get == c
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L384-L424" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            These are just the highlights of the most common operations on a
            <code>Bytes</code>. There are many more methods on <code>Bytes</code>
            instances as well as on the <code>Bytes</code> companion object, but
            you can explore those yourselves in your editor's autocomplete
            menu.
</p>
        <p>
            In general, it is reasonable to use <code>Bytes</code> throughout
            your codebase where-ever you need to represent binary data. In the
            few cases where performance is of utmost importance, or you really
            need read-write mutability, an <code>Array[Byte]</code> will be
            necessary, but for the majority of un-changing blobs-of-bytes a
            <code>Bytes</code> will do just fine.

</p>
    <h1 id="ByteHelpers" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ByteHelpers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Byte Helpers</h1>
        <p>
            Apart from providing an equivalent API for byte parsing,
            FastParse's byte-parsers also provide some helper functions for
            conveniently dealing with binary blobs.
</p>
        <h2 id="HexBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#HexBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Hex Bytes</h2>
            <p>
                FastParse includes Scodec's hex-interpolator:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

// Constructing `Bytes` via their hex values
assert(
  hex&quot;01 ff&quot; == Bytes(0x01, 0xff),

  hex&quot;01 ff&quot; == Bytes.fromHex(&quot;01 ff&quot;).get,

  hex&quot;&quot;&quot;
    de ad be ef
    ca fe ba be
  &quot;&quot;&quot; == Bytes(
    0xde, 0xad, 0xbe, 0xef,
    0xca, 0xfe, 0xba, 0xbe
  ),

  hex&quot;&quot;&quot;
  de ad be ef
  ca fe ba be
  &quot;&quot;&quot; == Bytes.fromHex(&quot;&quot;&quot;
    de ad be ef
    ca fe ba be
  &quot;&quot;&quot;).get
)


// You can interpolate Bytes into hex literals

val beef = hex&quot;de ad be ef&quot;
val cafeBytes = Bytes(0xca, 0xfe)
assert(
  hex&quot;$beef $cafeBytes ba be&quot; == Bytes(
    0xde, 0xad, 0xbe, 0xef,
    0xca, 0xfe, 0xba, 0xbe
  )
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L426-L463" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                This is a macro
                that converts the hex literal in a <code>Bytes</code> value at
                compile time. This should be both fast and safe: if you have
                a type in your hex literal it generates and error at compile
                time.
</p>
        <h2 id="prettyBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#prettyBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>prettyBytes</h2>
            <p>
                This function converts a byte array into a nicely-readable
                hex-grid.
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val blob = Bytes(
  &quot;The quick brown fox jumps over the lazy dog. She sells &quot; +
  &quot;sea shells on the sea shore but the shells she sells she &quot; +
  &quot;sells no more. Peter piper picked a pack of pickled peppers.&quot;:_*
)
assert( prettyBytes(blob) ==
  &quot;&quot;&quot;       0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
    |
    |0      54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20
    |16     66 6f 78 20 6a 75 6d 70 73 20 6f 76 65 72 20 74
    |32     68 65 20 6c 61 7a 79 20 64 6f 67 2e 20 53 68 65
    |48     20 73 65 6c 6c 73 20 73 65 61 20 73 68 65 6c 6c
    |64     73 20 6f 6e 20 74 68 65 20 73 65 61 20 73 68 6f
    |80     72 65 20 62 75 74 20 74 68 65 20 73 68 65 6c 6c
    |96     73 20 73 68 65 20 73 65 6c 6c 73 20 73 68 65 20
    |112    73 65 6c 6c 73 20 6e 6f 20 6d 6f 72 65 2e 20 50
    |128    65 74 65 72 20 70 69 70 65 72 20 70 69 63 6b 65
    |       ...&quot;&quot;&quot;.stripMargin
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L466-L487" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                This makes it easier for you to look for byte-ranges,
                count offsets, and that sort of thing. By default, it only shows
                the first 8 rows of the byte array. You can specify
                <code>markers</code> if you want to view portions of the byte
                array around other indices, and <code>prettyBytes</code> will add
                markers so you can see exactly the spots you specified:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val blob = Bytes(
  &quot;The quick brown fox jumps over the lazy dog. She sells &quot; +
  &quot;sea shells on the sea shore but the shells she sells she &quot; +
  &quot;sells no more. Peter piper picked a pack of pickled peppers.&quot;:_*
)

assert( prettyBytes(blob, markers = Seq(75, 100)) ==
  &quot;&quot;&quot;       0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
    |
    |0      54 68 65 20 71 75 69 63 6b 20 62 72 6f 77 6e 20
    |16     66 6f 78 20 6a 75 6d 70 73 20 6f 76 65 72 20 74
    |32     68 65 20 6c 61 7a 79 20 64 6f 67 2e 20 53 68 65
    |48     20 73 65 6c 6c 73 20 73 65 61 20 73 68 65 6c 6c
    |64     73 20 6f 6e 20 74 68 65 20 73 65 61 20 73 68 6f
    |                                        ^
    |80     72 65 20 62 75 74 20 74 68 65 20 73 68 65 6c 6c
    |96     73 20 73 68 65 20 73 65 6c 6c 73 20 73 68 65 20
    |                   ^
    |112    73 65 6c 6c 73 20 6e 6f 20 6d 6f 72 65 2e 20 50
    |128    65 74 65 72 20 70 69 70 65 72 20 70 69 63 6b 65
    |144    64 20 61 20 70 61 63 6b 20 6f 66 20 70 69 63 6b
    |160    6c 65 64 20 70 65 70 70 65 72 73 2e&quot;&quot;&quot;.stripMargin
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L489-L514" target="_blank"><i class="fa fa-link "></i></a></pre>

    <h1 id="Byte-SpecificParsers" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Byte-SpecificParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Byte-Specific Parsers</h1>
        <p>
            Many byte formats heavily use the concept of a fixed width &quot;word&quot;
            or &quot;double&quot;-word, always a multiple-of-two bytes, and usually
            parsed into the corresponding <a href="https://en.wikipedia.org/wiki/Two%27s_complement">twos-complement</a> integer or
            <a href="https://en.wikipedia.org/wiki/Floating_point">floating point</a>
            number. <code>fastparse.byte</code> provides built in support for these.
</p>
        <h2 id="BS" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#BS" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>BS</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val parser = P( BS(0xDE, 0xAD, 0xBE, 0xEF) )

val Parsed.Success((), 4) = parser.parse(Bytes(0xDE, 0xAD, 0xBE, 0xEF))
val Parsed.Failure(_, 0, _) = parser.parse(Bytes(0xCA, 0xFE, 0xBA, 0xBE))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L549-L555" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                This is the equivalent to the <a href="#Basic">Basic</a> literal string
                parser in when parsing strings. If the input matches the given
                sequence of bytes exactly, it the parse succeeds; if the input
                does not match or there's not enough input, the parse fails.
</p>
            <p>
                You can also pass in a ByteString to <code>BS</code> instead of
                individual byte values:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val parser1 = P( BS(hex&quot;deadbeef&quot;) )

val Parsed.Success((), 4) = parser1.parse(Bytes(0xDE, 0xAD, 0xBE, 0xEF))
val Parsed.Failure(_, 0, _) = parser1.parse(Bytes(0xCA, 0xFE, 0xBA, 0xBE))

val bytes = Bytes(0xDE, 0xfAD, 0xBE, 0xEF)
val parser2 = P( BS(bytes) )

val Parsed.Success((), 4) = parser1.parse(Bytes(0xDE, 0xAD, 0xBE, 0xEF))
val Parsed.Failure(_, 0, _) = parser1.parse(Bytes(0xCA, 0xFE, 0xBA, 0xBE))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L558-L570" target="_blank"><i class="fa fa-link "></i></a></pre>

        <h2 id="WordN" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#WordN" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>WordN</h2>
            <p>
                <code>fastparse.byte</code> provides convenient parsers for the common
                case of parsing 1, 2, 4, and 8-byte &quot;words&quot;.</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

def allZeroesByteArray = Bytes(0, 0, 0, 0, 0, 0, 0, 0)

val p1 = P( AnyByte )
val Parsed.Success((), index1) = p1.parse(allZeroesByteArray)
assert(index1 == 1)


val p2 = P( Word16 )
val Parsed.Success((), index2) = p2.parse(allZeroesByteArray)
assert(index2 == 2)


val p3 = P( Word32 )
val Parsed.Success((), index3) = p3.parse(allZeroesByteArray)
assert(index3 == 4)


val p4 = P( Word64 )
val Parsed.Success((), index4) = p4.parse(allZeroesByteArray)
assert(index4 == 8)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L611-L633" target="_blank"><i class="fa fa-link "></i></a></pre>


            <p>
                These parsers do not capture any result, but merely consume the
                bytes and move the index forward.
                If you want to capture the bytes as an
                <code>Array[Byte]</code>, use the <code>.!</code> to <a href="#Capture">Capture</a>
                them. If you want to capture them as various sorts of
                integers or numbers, use one of the <a href="#IntN">IntN</a> parsers
                listed below
</p>
        <h2 id="IntN" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#IntN" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>IntN</h2>
            <p>
                FastParse provides parsers to capture single bytes and return
                them, as signed <code>Byte</code>s.</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val p = P( Int8 )


val Parsed.Success(result1, _) = p.parse(Bytes(123)) // 7b
assert(result1 == 123)


val Parsed.Success(result2, _) = p.parse(Bytes(-123)) // 85
assert(result2 == -123)


val Parsed.Success(result3, _) = p.parse(Bytes(-1)) // ff
assert(result3 == -1)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L636-L651" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                An unsigned versions of the parser
                is available, that lifts the result into a <code>Short</code> since
                the higher-values of an unsigned byte (e.g. <code>128</code>) cannot
                fit into a signed <code>Byte</code>, which maxes out at positive
                <code>127</code>.
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val p = P( UInt8 )


val Parsed.Success(result1, _) = p.parse(Bytes(123)) // 7b
assert(result1 == 123)


val Parsed.Success(result2, _) = p.parse(Bytes(-123)) // 85
assert(result2 == 133)


val Parsed.Success(result3, _) = p.parse(Bytes(-1)) // ff
assert(result3 == 255)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L655-L670" target="_blank"><i class="fa fa-link "></i></a></pre>

            
            <p>
                Apart from capturing <code>Byte</code>s, FastParse also provides
                parsers which capture <code>Short</code>s, <code>Int</code>s and <code>Long</code>s.
                These come in both big-<a href="https://en.wikipedia.org/wiki/Endianness">endian</a> (<code>BE</code> below) and little-<a href="https://en.wikipedia.org/wiki/Endianness">endian</a>
                (<code>LE</code>) versions:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val p1 = P( BE.Int16 )
val Parsed.Success(result1, _) = p1.parse(Bytes(1, 0)) // 01 00
assert(result1 == 256)


val p2 = P( LE.Int16 )
val Parsed.Success(result2, _) = p2.parse(Bytes(1, 0)) // 01 00
assert(result2 == 1)


val p3 = P( BE.Int32 )
val bytes3 = Bytes(-128, 0, 0, 0) // ff 00 00 00
val Parsed.Success(result3, _) = p3.parse(bytes3)
assert(result3 == -2147483648)


val p4 = P( LE.Int32 )
val bytes4 = Bytes(-128, 0, 0, 0) // ff 00 00 00
val Parsed.Success(result4, _) = p4.parse(bytes4)
assert(result4 == 128)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L673-L695" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                As well as signed and un-signed versions
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val p1 = P( BE.Int64 )
val bytes1 = Bytes(1, 0, 0, 0, 0, 0, 0, 0) // 01 00 00 00 00 00 00 00
val Parsed.Success(result2, _) = p1.parse(bytes1)
assert(result2 == 72057594037927936L)


val p2 = P( BE.Int32 )
val bytes2 = Bytes(-128, -128, -128, -128) // 80 80 80 80
val Parsed.Success(result3, _) = p2.parse(bytes2)
assert(result3 == -2139062144)


val p3 = P( BE.UInt32 )
val bytes3 = Bytes(-128, -128, -128, -128) // 80 80 80 80
val Parsed.Success(result4, _) = p3.parse(bytes3)
assert(result4 == 2155905152L)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L699-L717" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                The unsigned versions of all these parsers max out at
                <code>Int32</code>; this is because there is no primitive type in
                Scala that can hold the higher-values of an unsigned 64-bit
                <code>Long</code>.
</p>
            <p>
                Note the difference between <code>LE</code> and <code>BE</code> versions of the
                <code>IntN</code> parsers; there are
                <a href="https://en.wikipedia.org/wiki/Endianness">two standards of ordering bytes</a>,
                so you have to pick which one you want to use. You can also <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import LE._</code>
                or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import BE._</code> if the endian-ness is the same throughout
                your parser, and then use <code>Int16</code>/<code>Int32</code>/<code>Int64</code> directly.
                Typically, big-endian formats are common in networking applications
                (e.g. UDP packets) while little-endian formats are common in operating
                systems and micro-processors.
</p>
        <h2 id="FloatN" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#FloatN" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>FloatN</h2>
            <p>
                Apart from parsing integers using <a href="#IntN">IntN</a>,
                <code>fastparse.byte</code> also contains parsers for common floating
                point numbers. These come in both big-endian/little-endian
                and 32/64-bit versions.
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val p1 = P( BE.Float32 )
val bytes1 = Bytes(64, 73, 15, -37) // 40 49 0f db
val Parsed.Success(result1, _) = p1.parse(bytes1)
assert(math.abs(result1 - 3.1415927) &lt; 0.00001)


val p2 = P( LE.Float32 )
val bytes2 = Bytes(-37, 15, 73, 64) // db 0f 49 40
val Parsed.Success(result2, _) = p2.parse(bytes2)
assert(math.abs(result2 - 3.1415927) &lt; 0.00001)


val p3 = P( BE.Float64 )
val bytes3 = Bytes(64, 9, 33, -5, 84, 68, 45, 24) // 40 09 21 fb 54 44 2d 18
val Parsed.Success(result3, _) = p3.parse(bytes3)
assert(math.abs(result3 - 3.1415927) &lt; 0.00001)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L721-L739" target="_blank"><i class="fa fa-link "></i></a></pre>

    <h1 id="EquivalentByteParsers" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#EquivalentByteParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Equivalent Byte Parsers</h1>
        <p>
            Apart from the byte-specific parsers mentioned above, Fastparse's
            byte-parsing API has many of the
</p>
        <ul>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">BS</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ByteSeq</code> is an alias for
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Array[Byte]</code>, and is used for parsing hard-coded
                sequences of bytes. This is equivalent to the most basic
                <a href="#Basic">literal string parsers</a> in Fastparse's
                string-parsing API</li>
            <li>
                <a href="#AnyChar">AnyChar</a>/<code>AnyChars</code> becomes <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">AnyByte</code>/<code>AnyBytes</code></li>
            <li>
                <a href="#CharPred">CharPred</a> becomes <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">BytePred</code></li>
            <li>
                <a href="#CharIn">CharIn</a> becomes <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ByteIn</code></li>
            <li>
                <a href="#CharsWhile">CharsWhile</a> becomes <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">BytesWhile</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">StringIn</code> becomes <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">SeqIn</code>
</li></ul>
        <p>
            For example, here is a small example using <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">BS</code>
            primitives and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">AnyByte</code>
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val ab = P( BS(1) ~ AnyByte.! ~ BS(1) )

val Parsed.Success(res, 3) = ab.parse(hex&quot;01 42 01&quot;)
assert(res == Bytes(0x42))

val failure @ Parsed.Failure(parser, 2, _) = ab.parse(hex&quot;01 42 43 01&quot;)

assert(
  parser == (BS(1): P0),
  failure.msg == &quot;&quot;&quot; &quot;01&quot;:2 ...&quot;43 01&quot; &quot;&quot;&quot;.trim
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L191-L205" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Apart from the changes listed above, FastParse's byte-parsing API works about
            same as it's string-parsing API. <a href="#Sequence">Sequence</a>, <a href="#Repeat">Repeat</a>,
            <a href="#Optional">Optional</a>, <a href="#Either">Either</a>, <a href="#Capture">Capture</a>, <a href="#Map">Map</a>,
            <a href="#FlatMap">FlatMap</a>, <a href="#Filter">Filter</a> and many other operators all work
            the same when parsing bytes as they do when parsing strings.
</p>
        <p>
            The process of <a href="#DebuggingParsers">Debugging Parsers</a>, <a href="#UsingCuts">Using Cuts</a>
            or <a href="#UsingLog">Using Log</a> to figure out what is going on, is all identical
            between FastParse's byte-parsing and string-parsing APIs.
</p>
        <p>
            Here are a bunch of examples demonstrating the use of most of
            FastParse's byte-parsing features:
</p>
        <h2 id="SimpleBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#SimpleBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Simple Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val parseA = P( BS(1, 2, 3) )

val Parsed.Success((), 3) = parseA.parse(Bytes(1, 2, 3))

val Parsed.Success((), 3) = parseA.parse(hex&quot;01 02 03&quot;)

val Parsed.Failure(lastParser, index, extra) = parseA.parse(Bytes(2))
assert(
  lastParser == (BS(1, 2, 3): P0),
  index == 0,
  extra.traced.trace == &quot;&quot;&quot;parseA:0 / &quot;01 02 03&quot;:0 ...&quot;02&quot;&quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L10-L24" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                This is the simplest byte-parser available: a single <code>BS</code>
                containing the bytes you want to match.
</p>
        <h2 id="SequenceBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#SequenceBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Sequence Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val ab = P( BS(1) ~ BS(2) )

val Parsed.Success(_, 2) = ab.parse(Bytes(1, 2))

val Parsed.Failure(parser, 1, _) = ab.parse(hex&quot;01 01&quot;) // or BS(1, 1)
assert(parser == (BS(2): P0))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L27-L35" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                <code>~</code> matches the left-side parser, and then the right-side
                parser. You can chain arbitrarily many of these
</p>
        <h2 id="RepeatBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#RepeatBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Repeat Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val ab = P( BS(1).rep ~ BS(2) )
val Parsed.Success(_, 8) = ab.parse(hex&quot;01 01 01 01 01 01 01 02&quot;)
val Parsed.Success(_, 4) = ab.parse(hex&quot;01 01 01 02&quot;)

val abc = P( BS(1).rep(sep = BS(2)) ~ BS(3) )
val Parsed.Success(_, 8) = abc.parse(hex&quot;01 02 01 02 01 02 01 03&quot;)
val Parsed.Failure(parser, 3, _) = abc.parse(hex&quot;01 02 01 01 02 01 03&quot;)

val ab4 = P( BS(1).rep(min = 2, max = 4, sep = BS(2)) )
val Parsed.Success(_, 7) = ab4.parse(hex&quot;01 02 01 02 01 02 01 02 01 02 01 02 01 02 01 02&quot;)

val ab4c = P( BS(1).rep(min = 2, max = 4, sep = BS(2)) ~ BS(3) )
val Parsed.Failure(_, 1, _) = ab4c.parse(hex&quot;01 03&quot;)
val Parsed.Success(_, 4) = ab4c.parse(hex&quot;01 02 01 03&quot;)
val Parsed.Success(_, 8) = ab4c.parse(hex&quot;01 02 01 02 01 02 01 03&quot;)
val Parsed.Failure(_, 7, _) = ab4c.parse(hex&quot;01 02 01 02 01 02 01 02 01 03&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L38-L56" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                <code>.rep</code> lets you repeat a parser zero or more times. By
                default, this also allows the parser to not match at all
                (zero times), but you can pass in <code>min = </code> and <code>max = </code>
                to bound the number of repetitions within a certain range,
                <code>exactly = </code> to match only a fixed number of bytes (useful
                for fixed-with data-fields) or a separator via <code>sep = </code> if
                you are parsing bytes delimited by zeroes or some other
                separator.
</p>
        <h2 id="OptionalBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#OptionalBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Optional Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val option = P( BS(3).? ~ BS(1).rep().! ~ End )

val Parsed.Success(res1, 3) = option.parse(hex&quot;03 01 01&quot;)
assert(res1 == Bytes(1, 1))

val Parsed.Success(res2, 2) = option.parse(hex&quot;01 01&quot;)
assert(res2 == Bytes(1, 1))

val Parsed.Success(res3, 1) = option.parse(hex&quot;01&quot;)
assert(res3 == Bytes(1))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L59-L71" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                <code>.?</code> lets the parser continue if it failed, trying the
                next thing if it doesn't parse. Above, you can see it
                can either parse the `01` with or without a preceding `03`.
</p>
        <h2 id="EitherBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#EitherBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Either Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val either = P( (BS(2, 2) | BS(3, 3, 3) | BS(4)).rep() ~ End )

// any combination of 04 or 02 02 or 03 03 03 succeeds
val Parsed.Success(_, 6) = either.parse(hex&quot;02 02 04 03 03 03&quot;)
val Parsed.Success(_, 6) = either.parse(hex&quot;02 02 04 02 02 04&quot;)

// if there's a 01, which is none of the above options, fails
val Parsed.Failure(parser, 3, _) = either.parse(hex&quot;02 02 04 01&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L74-L85" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                <code>|</code> tries the parser on the left, and if that fails,
                tries the parser on the right; if either of them passes it
                passes, but if both sides fail then whole either parser fails.
</p>
        <h2 id="End/StartBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#End/StartBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>End/Start Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val noEnd = P( BS(1).rep ~ BS(2) )
val withEnd = P( BS(1).rep ~ BS(2) ~ End )

val Parsed.Success(_, 4) = noEnd.parse(hex&quot;01 01 01 02 01&quot;)
val Parsed.Failure(End, 4, _) = withEnd.parse(hex&quot;01 01 01 02 01&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L89-L97" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                <code>End</code> only succeeds if it is at the end of the input. By
                default, byte parsers can succeed parsing prefixes of the
                input. If you want a parser to fail if it doesn't reach the end
                of an input, use <code>End</code>.</p>
            <p>
                <code>Start</code> is the opposite, only succeeding if at the start
                of the input:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val ab = P( ((BS(1) | Start) ~ BS(2)).rep ~ End ).!

val Parsed.Success(res1, 4) = ab.parse(hex&quot;01 02 01 02&quot;)
assert(res1 == Bytes(1, 2, 1, 2))

val Parsed.Success(res2, 5) = ab.parse(hex&quot;02 01 02 01 02&quot;)
assert(res2 == Bytes(2, 1, 2, 1, 2))

val Parsed.Failure(parser, 2, _) = ab.parse(hex&quot;01 02 02&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L100-L112" target="_blank"><i class="fa fa-link "></i></a></pre>

        <h2 id="Pass/FailBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Pass/FailBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Pass/Fail Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val Parsed.Success((), 0) = Pass.parse(hex&quot;04 08 15 16 23 42&quot;)
val Parsed.Failure(Fail, 0, _) = Fail.parse(hex&quot;04 08 15 16 23 42&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L115-L119" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                <code>Pass</code>/<code>Fail</code> pass or fail all the time. This is
                useful if you need a &quot;stub&quot; <code>Parser</code> that always behaves
                in some fixed way.
</p>
        <h2 id="IndexBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#IndexBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Index Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val finder = P( BS(1, 1, 1).rep ~ Index ~ BS(2, 2, 2) ~ BS(3, 3, 3).rep )

val Parsed.Success(9, _) = finder.parse(hex&quot; 01 01 01  01 01 01  01 01 01  02 02 02  03 03 03&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L122-L127" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                <code>Index</code> consumes no input, but returns the current index
                that we've parsed until. Useful for capturing information for
                debugging later.
</p>
        <h2 id="CaptureBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#CaptureBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Capture Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val capture1 = P( BS(1).rep.! ~ BS(2) ~ End )

val Parsed.Success(res1, 4) = capture1.parse(hex&quot;01 01 01 02&quot;)
assert(res1 == Bytes(1, 1, 1))

val capture2 = P( BS(1).rep.! ~ BS(2).! ~ End )

val Parsed.Success(res2, 4) = capture2.parse(hex&quot;01 01 01 02&quot;)
assert(res2 == (Bytes(1, 1, 1), Bytes(2)))

val capture3 = P( BS(1).rep.! ~ BS(2).! ~ BS(3).! ~ End )

val Parsed.Success(res3, 5) = capture3.parse(hex&quot;01 01 01 02 03&quot;)
assert(res3 == (Bytes(1, 1, 1), Bytes(2), Bytes(3)))

val captureRep = P( BS(1).!.rep ~ BS(2) ~ End )

val Parsed.Success(res4, 4) = captureRep.parse(hex&quot;01 01 01 02&quot;)
assert(res4 == Seq(Bytes(1), Bytes(1), Bytes(1)))

val captureOpt = P( BS(1).rep ~ BS(2).!.? ~ End )

val Parsed.Success(res5, 4) = captureOpt.parse(hex&quot;01 01 01 02&quot;)
assert(res5 == Some(Bytes(2)))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L130-L156" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                <code>.!</code> captures the range of the modified bytes as a
                <a href="#Bytes">Bytes</a> object, which you can then use for whatever
                you want. A <code>.!</code> inside an <a href="#OptionalBytes">Optional Bytes</a>
                parser becomes an <code>Option</code>, and a <code>.!</code> inside a
                <a href="#RepeatBytes">Repeat Bytes</a> parser becomes a <code>Seq</code>.
</p>
            <p>
                If you want to capture one of the common formats of 8-, 16-,
                32- or 64-bit integers of floating point numbers, you should
                probably use some of the <a href="#Byte-SpecificParsers">Byte-Specific Parsers</a>
                instead. You could do it yourself by assembling the number
                from the raw <code>Bytes</code>, but use the built-ins is less
                tedious and will have better performance.
</p>
        <h2 id="AnyBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#AnyBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Any Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val ab = P( BS(1) ~ AnyByte.! ~ BS(1) )

val Parsed.Success(res, 3) = ab.parse(hex&quot;01 42 01&quot;)
assert(res == Bytes(0x42))

val failure @ Parsed.Failure(parser, 2, _) = ab.parse(hex&quot;01 42 43 01&quot;)

assert(
  parser == (BS(1): P0),
  failure.msg == &quot;&quot;&quot; &quot;01&quot;:2 ...&quot;43 01&quot; &quot;&quot;&quot;.trim
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L191-L205" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Consumes any single byte. You can also use
                <code>AnyBytes(count: Int)</code> to consume a fixed number of bytes.
                Does not capture anything unless you explicitly
                <a href="#CaptureBytes">Capture Bytes</a>, and
</p>
        <h2 id="PositiveLookaheadBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#PositiveLookaheadBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Positive Lookahead Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val keyword = P( (BS(1, 2, 3) ~ &amp;(BS(4))).!.rep )

val Parsed.Success(res, _) = keyword.parse(hex&quot;01 02 03 04&quot;)
assert(res == Seq(Bytes(1, 2, 3))
)
val Parsed.Success(Seq(), __) = keyword.parse(hex&quot;01 02 03 05&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L208-L216" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                <code>&amp;(...)</code> tries the inner parser to ensure it passes,
                but if so it backtracks to where it started before the
                subsequent parser runs. If the inner parser fails, it
                fails.
</p>
        <h2 id="NegativeLookaheadBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#NegativeLookaheadBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Negative Lookahead Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val keyword = P( BS(1, 2, 3) ~ !BS(0) ~ AnyByte ~ BS(5, 6, 7) ).!

val Parsed.Success(res, _) = keyword.parse(hex&quot;01 02 03 42 05 06 07&quot;)
assert(res == Bytes(1, 2, 3, 0x42, 5, 6, 7))

val Parsed.Failure(parser, 4, _) = keyword.parse(hex&quot;01 02 03 00 05 06 07&quot;)
assert(parser == !BS(0))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L219-L228" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                <code>!(...)</code> tries the inner parser to ensure it fails,
                but if so it backtracks to where it started before the
                subsequent parser runs. If the inner parser succeeds, this
                fails.
</p>
        <h2 id="MapBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#MapBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Map Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val binary = P( (BS(0) | BS(1)).rep.! )

val Parsed.Success(res, _) = binary.parse(hex&quot;01 01 00 00&quot;)
assert(res == Bytes(1, 1, 0, 0))

val binaryNum = P( binary.map(_.toArray.sum) )
val Parsed.Success(2, _) = binaryNum.parse(Bytes(0x01, 0x01, 0x00, 0x00))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L231-L240" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Lets you transform the current result of this parser (whether
                a <code>Byte</code>/<code>Short</code>/<code>Int</code>/<code>Long</code>/<code>Float</code>/<code>Double</code>
                from one of the <a href="#Byte-SpecificParsers">Byte-Specific Parsers</a> or a
                <a href="#Bytes">Bytes</a> from a <a href="#CaptureBytes">Capture Bytes</a>) into
                something else: put it in a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case class</code>, convert
                it to a <code>Array[Byte]</code>, whatever.
</p>
        <h2 id="FilterBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#FilterBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Filter Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val nullTerminated = P( (Int8.filter(_ != 0).rep().! ~ BS(0)).rep() )

val Parsed.Success(res, _) = nullTerminated .parse(
  hex&quot;de ad be ef 00 13 37 00&quot;
)
assert(res == Seq(hex&quot;de ad be ef&quot;, hex&quot;13 37&quot;))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L243-L251" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Lets you check a parser with a predicate; if the predicate
                fails, that parser fails.

</p>
        <h2 id="FlatMapBytes" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#FlatMapBytes" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>FlatMap Bytes</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val lengthPrefixed = P( Int8.flatMap(AnyBytes(_).!).rep() )

val Parsed.Success(res, _) = lengthPrefixed.parse(
  Bytes(0x04, 0xde, 0xad, 0xbe, 0xef, 0x02, 0x13, 0x37)
)
assert(res == Seq(Bytes(0xde, 0xad, 0xbe, 0xef), Bytes(0x13, 0x37)))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L254-L262" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                Lets you choose the subsequent parser based on the result of
                the previous parser; useful for length-delimited fields, where
                a preceding fixed-width length field determines how many
                subsequent bytes make up the actual contents of the field.
</p>
        <h2 id="BytesWhile" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#BytesWhile" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>BytesWhile</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val nullTerminated = P( (BytesWhile(_ != 0).! ~ BS(0)).rep() )

val Parsed.Success(res, _) = nullTerminated.parse(
  hex&quot;de ad be ef 00 13 37 00&quot;
)
assert(res == Seq(hex&quot;de ad be ef&quot;, hex&quot;13 37&quot;))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L266-L274" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                A fast way of consuming lots of bytes as long as the given
                predicate returns true. Useful for things like 0-delimited
                fields, where you want to consume the input until the next
                0 byte.</p>
            <p>
                The predicate is used to build a lookup table, which is then used
                to speed up parsing. You can use <code>BytesWhile.raw</code> if you want to
                avoid pre-computing the lookup table, in which case the predicate is
                re-run repeatedly during parsing.</p>
        <h2 id="BytesWhile" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#BytesWhile" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>BytesWhile</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val nullTerminated = P( (BytesWhileIn(hex&quot;de ad be ef&quot;.toSeq).! ~ BS(0)).rep() )

val Parsed.Success(res, _) = nullTerminated.parse(
  hex&quot;de ad be ef 00 13 37 00&quot;
)
assert(res == Seq(hex&quot;de ad be ef&quot;))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L277-L285" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                A fast way of consuming lots of bytes as long as the given
                predicate returns true. Useful for things like 0-delimited
                fields, where you want to consume the input until the next
                0 byte.</p>
            <p>
                The predicate is used to build a lookup table, which is then used
                to speed up parsing. You can use <code>BytesWhile.raw</code> if you want to
                avoid pre-computing the lookup table, in which case the predicate is
                re-run repeatedly during parsing.
</p>
        <h2 id="BytePred" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#BytePred" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>BytePred</h2>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

val nullTerminated = P( (BytePred(_ != 0).rep().! ~ BS(0)).rep() )

val Parsed.Success(res, _) = nullTerminated.parse(
  Bytes(0xde, 0xad, 0xbe, 0xef, 0x00, 0x13, 0x37, 0x00)
)
assert(res == Seq(Bytes(0xde, 0xad, 0xbe, 0xef), Bytes(0x13, 0x37)))</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L288-L296" target="_blank"><i class="fa fa-link "></i></a></pre>
            <p>
                Consumes a single-byte, satisfying any arbitrary predicate.
</p>
            <p>
                The predicate is used to build a lookup table, which is then used
                to speed up parsing. You can use <code>BytePred.raw</code> if you want to
                avoid pre-computing the lookup table, in which case the predicate is
                re-run repeatedly during parsing.
</p>
    <h1 id="ExampleByteParsers" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ExampleByteParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Example Byte Parsers</h1>

        <h2 id="UDPPackets" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UDPPackets" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>UDP Packets</h2>
            <p>
                This is an example <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP Datagram</a>
                packet-parser implemented using FastParse's byte-parsing api:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">import fastparse.byte.all._

case class UdpPacket(sourcePort: Int,
                     destPort: Int,
                     checkSum: Int,
                     data: Bytes)

// BE.UInt16 stands for big-endian unsigned-16-bit-integer parsers
val udpHeader = P( BE.UInt16 ~ BE.UInt16 ~ BE.UInt16 ~ BE.UInt16 )

val udpParser = P(
  for{
    (sourcePort, destPort, length, checkSum) &lt;- udpHeader
    data &lt;- AnyBytes(length - 8).!
  } yield UdpPacket(sourcePort, destPort, checkSum, data)
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L573-L590" target="_blank"><i class="fa fa-link "></i></a></pre>

            <p>
                Here's how to use it:
</p>
            <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val bytes = hex&quot;&quot;&quot;
  04 89 00 35 00 2C AB B4 00 01 01 00 00 01 00 00
  00 00 00 00 04 70 6F 70 64 02 69 78 06 6E 65 74
  63 6F 6D 03 63 6F 6D 00 00 01 00 01
&quot;&quot;&quot;

val Parsed.Success(packet, _) = udpParser.parse(bytes)
assert(
  packet.sourcePort == 1161,
  packet.destPort == 53,
  packet.checkSum == 43956,
  packet.data.length == 36,
  packet.data == hex&quot;&quot;&quot;
    00 01 01 00 00 01 00 00 00 00 00 00 04 70 6F 70
    64 02 69 78 06 6E 65 74 63 6F 6D 03 63 6F 6D 00
    00 01 00 01
  &quot;&quot;&quot;
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/ByteTests.scala#L590-L608" target="_blank"><i class="fa fa-link "></i></a></pre>

        <h2 id="BmpParser" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#BmpParser" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>BmpParser</h2>
            <p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">BmpParser</code> is a good example of a slightly more complex byte parser:
                a parser for <a href="https://en.wikipedia.org/wiki/BMP_file_format">Bitmap image files</a>.
                It's not small, but structure is pretty simple. It does not
                support the full breadth of the Bitmap format, but it supports
                enough to parse many common images.</p>
            <p>
                Like all other FastParse parsers, FastParse's Byte parsers all
                run in the browser via Scala.js, and so does BmpParser! Here
                we have a live demo: upload a bitmap file, and will parse it
                and print out some simple metadata (width, height, etc.):
</p>
            <div id="bmpdiv"></div>
            <script>demo.DemoMain.bmp(document.getElementById("bmpdiv"))</script>
            <i>
                If you haven't any bmp around, you can download classic
                <a href="https://raw.githubusercontent.com/lihaoyi/fastparse/master/fastparseByte/jvm/src/test/resources/lena.bmp">lena</a>.
</i>
            <h3 id="BmpParserWalkthrough" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#BmpParserWalkthrough" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>BmpParser Walkthrough</h3>
                <p>
                    Here, we'll walk through the implementation of BmpParser,
                    which should give you a taste of how FastParse's
                    <a href="#ByteParsers">Byte Parsers</a> work in general.</p>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.ByteUtils.LE._</code>

                <p>
                    First of all we import package for Little-Endian support, because BMP format use it.
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val bmp = P(
  for{
    fileHeaderData &lt;- fileHeader
    headerData &lt;- header
    pixels &lt;- bmpRow(headerData.infoPart.width, headerData.infoPart.bitsPerPixel)
                .rep(exactly=headerData.infoPart.height)
  }yield Bmp(fileHeaderData, headerData, pixels.reverse)
)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/BmpTests.scala#L98-L106" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    Bmp file consists of two headers (file header and info header) and pixels in rows with padding,
                    the difficulties are that there are several versions of headers and the parser should distinct them and
                    process them correctly, and that the size and padding of rows in bmp file depends on information from header.
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val fileHeader = {
  val headerType = UInt16
  val size = Int32
  val offset = Int32
  P( headerType ~ size ~ Word16 ~ Word16 ~ offset ).map(FileHeader.tupled)
}

val infoHeaderPart = {
  val width = Int32
  val height = Int32
  val colorPlanes = UInt16
  val bitsPerPixel = UInt16
  val compression = Int32
  val imageSize = Int32
  val horzRes = Int32
  val vertRes = Int32
  val colorUsed = Int32
  val colorsImportant = Int32
  P(
    width ~ height ~
      colorPlanes ~ bitsPerPixel ~
      compression ~ imageSize ~
      horzRes ~ vertRes ~
      colorUsed ~ colorsImportant
  ).map(
    s =&gt; BitmapInfoHeader(BitmapInfoHeaderPart.tupled(s))
  )
}

val v2HeaderPart = {
  val RgbPart = P( Word32 )
  P( infoHeaderPart ~ RgbPart.rep(exactly=3) )
}

val v3HeaderPart = {
  val AlphaPart = P( Word32 )
  P( v2HeaderPart ~ AlphaPart )
}

val v4HeaderPart = P( v3HeaderPart ~ AnyBytes(52) )

val v5HeaderPart = P( v4HeaderPart ~ AnyBytes(16) )


val infoHeader = P( BS(40, 0, 0, 0) /* 40 bytes */ ~/ infoHeaderPart )
val v2Header = P( BS(52, 0, 0, 0) ~/ v2HeaderPart )
val v3Header = P( BS(56, 0, 0, 0) ~/ v3HeaderPart )
val v4Header = P( BS(108, 0, 0, 0) ~/ v4HeaderPart )
val v5Header = P( BS(124, 0, 0, 0) ~/ v5HeaderPart )

val header = P( infoHeader | v2Header | v3Header | v4Header | v5Header)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/BmpTests.scala#L38-L90" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    The first problem is reflected in similar parsers describing 5 versions of info header
                    (<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">v2HeaderPart</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">v2Header</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">v3HeaderPart</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">v3Header</code>...).
</p>
                <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">def bmpRow(width: Int, bitsPerPixel: Int): P[Seq[Pixel]] = {
  val bytesPerPixel = bitsPerPixel / 8
  val padding = (width * bytesPerPixel) % 4
  P( AnyBytes(bytesPerPixel).!.~/.rep(exactly=width) ~/ AnyBytes(padding) ).map(
    pixels =&gt; pixels.map(Pixel)
  )
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/BmpTests.scala#L90-L98" target="_blank"><i class="fa fa-link "></i></a></pre>

                <p>
                    The second problem in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">bmpRow</code> function that computes the parameters of row and creates parser on a fly.
</p>
                <p>
                    Note also few tricks for parsing binary data.</p>
                <ul>
                    <li>
                        <b>
                            Most of main elements in bmp format has very simple and plain structure. <br /></b>
                         For instance <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fileHeader</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">infoHeaderPart</code>
                         are just sequences of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">AnyDwordI</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">AnyWordI</code></li>
                    <li>
                        <b>
                            The extensive usage of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(exactly=...)</code>.<br /></b>
                        This is due to the fact that many binary formats depends on constant-sized blocks
                        and the easiest and fastest method to parse them is to write <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep(exactly=...)</code>.</li>
                    <li>
                        <b>
                            The same extensive usage of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">for</code>-comprehensions.<br /></b>
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">for</code>-comprehensions (equivalent to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">flatMap</code>)
                        allow to retrieve data from one parser and pass it to the next.
                        The most popular and primitive example is dynamic-sized array with
                        length written at the beginning. Similar algorithm is used in the
                        <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">bmp</code> when header information is passed to the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">bmpRow</code>
                        that returns new parser for row in this particular bmp file.
</li></ul>
        <h2 id="MidiParse" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#MidiParse" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>MidiParse</h2>
            <p>
                MidiParse is an example byte-parser written using FastParse, for
                parsing <a href="https://en.wikipedia.org/wiki/MIDI">MIDI music files</a>.
                Like all FastParse parsers, it compiles to Javascript via Scala.js and
                can run in the browser: below is a small widget that uses MidiParse to
                parse, analyze and play any Midi file you upload use Keith Horwood's
                <a href="https://github.com/keithwhor/audiosynth">AudioSynth</a> Javascript
                library.
</p>
            <div id="mididiv"></div>
            <script src="Audio.js" type="text/javascript"></script>
            <script>demo.DemoMain.midiparser(document.getElementById("mididiv"))</script>

            <p>
                If you don't have any midi files lying around, perhaps you could
                try one of these:
</p>
            <ul>
                
                    <li>
                        <a href="https://raw.githubusercontent.com/lihaoyi/fastparse/master/fastparseByte/jvm/src/test/resources/canon.mid">canon.mid</a>
</li>
                    <li>
                        <a href="https://raw.githubusercontent.com/lihaoyi/fastparse/master/fastparseByte/jvm/src/test/resources/go.mid">go.mid</a>
</li>
                    <li>
                        <a href="https://raw.githubusercontent.com/lihaoyi/fastparse/master/fastparseByte/jvm/src/test/resources/tonghua.mid">tonghua.mid</a>
</li></ul>
            <p>
                If you wish, you can also check out this project and run
                <code>sbt &quot;fastparseJVM/test:run go.mid&quot;</code> from the command line
                to play the same MIDI file using the same parser, but running on
                Scala-JVM and using the JVM's MIDI player rather than the browser's.
                In general, the JVM player is much more robust than the Web player:
                the Web player doesn't know how to handle changes in pitch bend,
                polyphonic pressure, channel pressure or controller, and plays
                all notes as a single piano-like instrument
</p>
            <p>
                MidiParse comprises about 50 lines of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">case class</code>es that
                define the structure of the midi file, and another 140 lines of
                FastParse code for parsing the MIDI from binary input:
</p>
            <ul>
                <li>
                    <a href="https://github.com/lihaoyi/fastparse/tree/master/fastparseByte/shared/src/test/scala/fastparse/byte/MidiParse.scala">MidiParse Source</a>
</li></ul>
            <p>
                MidiParse illustrates many of the quirks of writing a parser for
                a real-world binary format:
</p>
            <ul>
                <li>
                    How to parse various sorts of bit-packed integers: 8-bit,
                    16-bit, or 32-bit signed and unsigned integers (e.g. <code>UInt8</code>).
                    Even more obscure things like the 24-bit integer used to
                    store the <code>Tempo</code> of the music, or the variable-length
                    <code>varInt</code> parser keeps consuming individual bytes
                    until it finds one whose high-order bit is set, and then
                    concats them all into one variable-length integer.</li>
                <li>
                    <code>varString</code> and <code>varByte</code> parsers are a common
                    case of using <a href="#FlatMap">FlatMap</a> to parse a variable-length
                    data-field whose length is defined up-front</li>
                <li>
                    <code>midiEvent</code> and <code>metaEvent</code> show how to switch
                    on a single byte upfront and use that to decide how to
                    continue parsing a particular item, using
                    <a href="#FlatMap">FlatMap</a>/<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">for</code>-comprehensions</li>
                <li>
                    How to use <a href="#Filter">Filter</a> to narrow down the sort of
                    input a parser can parse, e.g. to narrow a
                    <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Int8: Parser[Byte]</code> into a parser that only
                    accepts non-negative bytes
</li></ul>
            <p>
                Other than these quirks, the majority of the parser is
                relatively straightforward FastParse code.

</p>
        <h2 id="ClassParser" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ClassParser" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>ClassParser</h2>
            <p>
                The other example byte-parser that FastParse provides is <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ClassParser</code>.
                It's quite a complex parser that process <code>.class</code> files with java bytecode,
                and parses them into a simple structured format. You can see the code here:
</p>
            <ul>
                <li>
                    <a href="https://github.com/lihaoyi/fastparse/tree/master/classparse/shared/src/main/scala/classparse">ClassParse</a></li></ul>
            <p>
                ClassParse is able to retrieve almost full information about given
                class including all methods, fields, subclasses, code and pack it
                into the convenient AST. On the similarity with other big parsers
                it has good set of unit-tests with tests which compile real projects
                from github (joda-time, junit4, jenkins and etc.) and check each built file.
</p>
            <p>
                Like all FastParse parsers, ClassParse compiles to Javascript using
                Scala.js and can run in the browser. Below is a short demo of ClassParse
                in action: upload any <code>.class</code> file full of Java byte code, and it
                will parse it and print out the names and signatures of all fields and
                methods define in that class:
</p>
            <div id="clssdiv"></div>
            <script>demo.DemoMain.clss(document.getElementById("clssdiv"))</script>

            <p>

                If you haven't any .class files around, you can download some examples
                to try:</p>
            <ul>
                
                
                    <li>
                        <a href="https://github.com/lihaoyi/fastparse/raw/master/classparse/shared/src/test/resources/Book.java">Book.java</a>
</li>
                    <li>
                        <a href="https://github.com/lihaoyi/fastparse/raw/master/classparse/shared/src/test/resources/Book.class">Book.class</a>
</li>
                    <li>
                        <a href="https://github.com/lihaoyi/fastparse/raw/master/classparse/shared/src/test/resources/Book2.java">Book2.java</a>
</li>
                    <li>
                        <a href="https://github.com/lihaoyi/fastparse/raw/master/classparse/shared/src/test/resources/Book2.class">Book2.class</a>
</li>
                    <li>
                        <a href="https://github.com/lihaoyi/fastparse/raw/master/classparse/shared/src/test/resources/CodeTest.java">CodeTest.java</a>
</li>
                    <li>
                        <a href="https://github.com/lihaoyi/fastparse/raw/master/classparse/shared/src/test/resources/CodeTest.class">CodeTest.class</a>
</li></ul>
            <p>
                You can download the classfiles and directly try them in this
                demo, or you can download the sources and compile them yourself
                with <code>javac</code> before uploading the generated class file.
</p>
            <p>
                This is available on Maven Central as
</p>
            <pre><code class="scala scalatex-site-Styles-highlightMe">&quot;com.lihaoyi&quot; %%% &quot;classparse&quot; % &quot;0.4.4&quot;</code></pre>


    
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Performance" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Performance<a class=" scalatex-site-Styles-headerLink" href="#Performance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        FastParse will never be able to compete with hand-written recursive descent parsers for speed. However, it's no slouch either; here's a comparison of FastParse with alternatives, using Parboiled2's JSON parsing benchmark, which parses a ~21,500 line JSON file:
</p>
    <table style="width: 100%;" class="pure-table">
        <thead>
            <th>Benchmark</th><th>Score</th><th>Error</th></thead>
        <tbody>
            <tr>
                <td>fastparse</td><td>80.536</td><td>± 0.942</td></tr>
            <tr>
                <td>fastparse-no-trace</td><td>89.873</td><td>± 0.875</td></tr>
            <tr>
                <td>argonaut</td><td>164.092</td><td>± 2.869</td></tr>
            <tr>
                <td>json4s-jackson</td><td>285.637</td><td>± 3.954</td></tr>
            <tr>
                <td>json4s-native</td><td>142.964</td><td>± 2.076</td></tr>
            <tr>
                <td>parboiled2</td><td>87.586</td><td>± 1.176</td></tr>
            <tr>
                <td>scala-parser-combinators</td><td>0.976</td><td>± 0.018</td></tr>
            <tr>
                <td>spray-json</td><td>189.784</td><td>± 2.825</td>

</tr></tbody></table>
    <p>
        These numbers are the number of iterations/second of parsing a sample <code>test.json</code> file, averaged over 200 runs. As you can see, the FastParse based parser comes within a factor of 4 of the fastest hand written parser (Jackson), is just as fast as the Parboiled2 based parser (slightly faster/slower depending if full tracing is enabled), and is almost 100x faster than the scala-parser-combinators library.
</p>
    <p>
        In exchange for the perf hit compared to hand-rolled solutions, you get the <a href="#Json">short, super-simple parser definition</a>, and excellent error free error reporting. While for super-high-performance use cases you may still want a hand-rolled parser, for many ad-hoc situations a FastParse parser would do just fine. Remember, even at &quot;only&quot; 89 iterations per second that is still parsing 1,900,000 lines of JSON every second!
</p>
    <p>
        A similar speed ratio can be seen in parsing a <a href="https://github.com/scala-js/scala-js/blob/master/compiler/src/main/scala/org/scalajs/core/compiler/GenJSCode.scala">sample Scala file</a> using FastParse, Parboiled2 and Scalac's inbuilt hand-written Scala-language parser:
</p>
    <table style="width: 100%;" class="pure-table">
        <thead>
            <th>Benchmark</th><th>Score</th><th>Error</th></thead>
        <tbody>
            <tr>
                <td>fastparse</td><td>320.7</td><td>15.4</td></tr>
            <tr>
                <td>fastparse-no-trace</td><td>434.7</td><td>23.4</td></tr>
            <tr>
                <td>parboiled2</td><td>1354</td><td>7.97</td></tr>
            <tr>
                <td>scalac</td><td>4888</td><td>113</td>
</tr></tbody></table>
    <p>
        These numbers are the number of iterations over 30 seconds, average of 4 runs, with 2 runs of warmup (discarded). FastParse performs worse here, at 11.5x slower than Scalac's in-built parser, and 3x slower than the equivalent Parboiled2-based parser. Depending on what you're doing, that may or may not be a problem: ScalaParse still makes progress at 57,027 lines of Scala per second, which despite being slower than the others is still blazing fast.
</p>
    <h1 id="ImprovingPerformance" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ImprovingPerformance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Improving Performance</h1>

        <p>
            There are many ways to improve performance of your FastParse parsers.
            If you study the example parsers included in the repo, those already
            have many of these techniques applied, and if you follow the same style
            you'll probably do ok. Nevertheless, here are some concrete tips:
</p>
        <ul>
            <li>
                <b>Understand your Parser's behavior</b>: using <a href="#Log">Log</a>, or
                by <a href="#InstrumentingParsers">Instrumenting Parsers</a>. Often poor performance is due
                to parsers doing the wrong thing: attempting more alternatives
                than they need to, or backtracking and repeating the same
                parse many times. Understanding the flow of how your parser works
                is the first step in identifying these issues and fixing them
</li>
            <li>
                <b>Avoid Backtracking</b>: FastParse parsers have unlimited backtracking,
                which is convenient for getting something working initially, but
                inconvenient when you want things to be fast. If you have a parser
                with lots of backtracking, see if you can factor out parts of it
                so they only get parsed once, e.g. turning <code>a ~ b | a ~ c</code> into
                <code>a ~ (b | c</code>
</li>
            <li>
                <b>Use <a href="#Cuts">Cuts</a></b>: although you can remove backtracking manually,
                it is easy to make a mistake and miss some of it, or for backtracking
                to creep back in as you make further changes to your parser. Cuts
                prevent that, ensuring that your parser never backtracks past certain
                points no matter what.

</li>
            <li>
                <b>Use <a href="#Intrinsics">Intrinsics</a></b>: things like <a href="#CharPred">CharPred</a>,
                <a href="#CharIn">CharIn</a>, <a href="#CharsWhile">CharsWhile</a>, <a href="#StringIn">StringIn</a>,
                <a href="#CharsWhileIn">CharsWhileIn</a> are orders of magnitude faster than
                implementing their behavior yourself with <code>|</code> and <code>.rep</code>.
                Use them where-ever possible
</li>
            <li>
                <b>Re-use your Parsers</b>: FastParse parsers are slightly expensive
                to create, but immutable and thread-safe and fast to run
                after they've been created. Take advantage of this by creating
                your parsers in top-level <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">object</code>s where-ever possible,
                so you only pay the creation cost once.

</li></ul>
    <h1 id="StartupPerformance" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#StartupPerformance" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Startup Performance</h1>

        <p>
            FastParse performs a lot of it's optimizations on-startup; this usually
            does not matter, e.g. if you're building a server or other long-running
            process, but sometimes it does. Particularly if you are using Scala.js,
            which has a combination of lower performance and higher expectations
            (Users hate waiting!)
</p>
        <p>
            To improve startup times, here are a few tips:
</p>
        <ul>
            <li>
                <b>Simplify the contents of your <a href="#CharPred">CharPred</a>s and <a href="#CharsWhile">CharsWhile</a>
                operators</b>: these tend to be pre-computed, so steady-state it doesn't matter
                at all how complex the predicate you feed into them is. However, that means
                during initialization, any slowness in the predicates are magnified.
</li>
            <li>
                <b>Replace <a href="#CharPred">CharPred</a> with <a href="#CharIn">CharIn</a> and
                <a href="#CharsWhile">CharsWhile</a> with <a href="#CharsWhileIn">CharsWhileIn</a></b>: you cannot
                always perform this replacement, but in the cases where you can,
                <a href="#CharIn">CharIn</a> and <a href="#CharsWhileIn">CharsWhileIn</a> are much faster to
                initialize than their predicate-based counterparts.</li>
            <li>
                <b>Use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.CharPredicates</code></b>: these are versions of
                the various <code>.isDigit</code>/<code>.isUpper</code>/etc.
                methods that are pre-computed for characters from 0 to 65535. This
                especially makes a difference when using FastParse in Scala.js,
                where the <code>.isXXX</code> methods tend to be much slower than on the JVM.
                Use the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.CharPredicates.isXXX(c)</code> methods within
                your <a href="#CharPred">CharPred</a>s or <a href="#CharsWhile">CharsWhile</a>s wherever possible</li></ul>

    

<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="DebuggingParsers" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Debugging Parsers<a class=" scalatex-site-Styles-headerLink" href="#DebuggingParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        The vast majority of your time working with FastParse, your parsers
        will be incorrect. This is almost by definition, because once your
        parser is correct, you'll be done and can go do something else with
        your life!
</p>
    <p>
        Even if your parsers are correct, often you'll find
        yourself parsing broken input:</p>
    <ul>
        <li>
            Perhaps a user typed in mal-formed code for your custom programming-language?</li>
        <li>
            Or someone corrupted your data files?</li>
        <li>
            Or some external service isn't properly following your
            protocol spec?
</li></ul>
    <p>
        No matter what goes wrong, <i>someone</i> will need to figure
        it out and fix it. Thus FastParse puts a lot of effort
        into making working with broken parsers and input as easy as possible.
</p>
    <p>
        Let's take an example Parser:
</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Foo{
  import fastparse.all._
  val plus = P( &quot;+&quot; )
  val num = P( CharIn('0' to '9').rep(1) ).!.map(_.toInt)
  val side = P( &quot;(&quot; ~ expr ~ &quot;)&quot; | num )
  val expr: P[Int] = P( side ~ plus ~ side ).map{case (l, r) =&gt; l + r}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L409-L418" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
        This is a simple parser that parses some basic arithmetic expressions: <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">1+2</code>, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(1+2)+(3+4)</code>, etc. It's simpler than <a href="#Math">Math</a> parser shown at the top of the page, as it does not handle multiple operators in a row e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">1+2+3+4</code>, nor does it handle operator precedence. Nevertheless it will be enough to show how error handling and debugging works.
</p>
    <p>
        If we run the parser on a bad input, though, we get this:

</p>
    <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">Foo.expr.parse(&quot;(1+(2+3x))+4&quot;),
&quot;&quot;&quot;Failure((&quot;(&quot; ~ expr ~ &quot;)&quot; | num):1:1 ...&quot;(1+(2+3x))&quot;)&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L419-L421" target="_blank"><i class="fa fa-link "></i></a></pre>

    <p>
        As you can see, the error message is pretty generic: &quot;i tried to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot; ~ expr ~ &quot;)&quot;</code> or a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code> at index <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">0</code>&quot;. Why does it tell us that?
</p>
    <h1 id="UsingCuts" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UsingCuts" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Using Cuts</h1>
        <p>
            The answer is that as far as FastParse knows, you could have wanted either the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot; ~ expr ~ &quot;)&quot;</code> or the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code> at that position, and it doesn't know which one. Thus even though it starts off parsing a paren, when that branch eventually fails (it tries to parse a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> at index 7, but finds a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;x&quot;</code>) it backtracks out of the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot; ~ expr ~ &quot;)&quot;</code> parser and then tries to parse <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code>. When that fails, it doesn't know which side was &quot;meant&quot; to succeed, and so it gives up and just tells you both sides failed to parse.</p>
        <p>
            Although FastParse doesn't know which branch was meant to succeed, <i>we</i> know that once we've parsed a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code>, it can no longer parse a number! Thus there's no point in backtracking and trying that side of the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">|</code>. We can tell FastParse this fact by adding <a href="#Cuts">Cuts</a> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">~/</code> after <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code>
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Foo{
  import fastparse.all._
  val plus = P( &quot;+&quot; )
  val num = P( CharIn('0' to '9').rep(1) ).!.map(_.toInt)
  val side = P( &quot;(&quot; ~/ expr ~ &quot;)&quot; | num )
  val expr: P[Int] = P( side ~ plus ~ side ).map{case (l, r) =&gt; l + r}
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L425-L432" target="_blank"><i class="fa fa-link "></i></a></pre>
        <p>
            Now, once FastParse sees a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code>, it can no longer backtrack! Thus it knows that whatever error occurs later, it <i>must</i> be because it failed to parse a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> and not because <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">num</code> failed. Then the error message becomes much more precise and useful:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">Foo.expr.parse(&quot;(1+(2+3x))+4&quot;),
&quot;&quot;&quot;Failure(&quot;)&quot;:1:8 ...&quot;x))+4&quot;)&quot;&quot;&quot;</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L433-L435" target="_blank"><i class="fa fa-link "></i></a></pre>


    <h1 id="UsingLog" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UsingLog" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Using Log</h1>
        <p>
            We can add <a href="#Log">Log</a> calls to make FastParse tell us a lot more about what a parser is doing. For example, if we want to know whenever a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> is being attempted, we can add <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> to those to parsers to find out:</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">object Foo{
  import fastparse.all._
  val plus = P( &quot;+&quot; )
  val num = P( CharIn('0' to '9').rep(1) ).!.map(_.toInt)
  val side = P( &quot;(&quot; ~/ expr ~ &quot;)&quot; | num ).log()
  val expr:P[Int] = P( side ~ plus ~ side ).map{case (l, r) =&gt; l + r}.log()
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L440-L449" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Then when you run it on an invalid input:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">Foo.expr.parse(&quot;(1+(2+3x))+4&quot;)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L449-L450" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            You get a dump of everything the logged parsers are trying to do
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">+expr:1:1
  +side:1:1
    +expr:1:2
      +side:1:2
      -side:1:2:Success(1:3)
      +side:1:4
        +expr:1:5
          +side:1:5
          -side:1:5:Success(1:6)
          +side:1:7
          -side:1:7:Success(1:8)
        -expr:1:5:Success(1:8)
      -side:1:4:Failure(side:1:4 / &quot;)&quot;:1:8 ...&quot;(2+3x))+4&quot;, cut)
    -expr:1:2:Failure(expr:1:2 / side:1:4 / &quot;)&quot;:1:8 ...&quot;1+(2+3x))+&quot;, cut)
  -side:1:1:Failure(side:1:1 / expr:1:2 / side:1:4 / &quot;)&quot;:1:8 ...&quot;(1+(2+3x))&quot;, cut)
-expr:1:1:Failure(expr:1:1 / side:1:1 / expr:1:2 / side:1:4 / &quot;)&quot;:1:8 ...&quot;(1+(2+3x))&quot;, cut)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/ExampleTests.scala#L454-L470" target="_blank"><i class="fa fa-link "></i></a></pre>


        <p>
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">+</code> is when a parser is started, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">-</code> is when it finishes with either a success or a failure. In the case of failure, it tells you what the stack was when it failed.</p>
        <p>
            The general strategy for adding <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code>s is:
</p>
        <ol>
            <li>
                Is my parser misbehaving? This is usually obvious from seeing parse failures when there shouldn't be</li>
            <li>
                Are any sub-parsers which I believe should be succeeding/failing/getting-called, aren't? Add logging to the sub-parsers. You can do this at the definition-site of the sub-parsers as shown above, or to the use-site e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side.log(&quot;SIDE 1&quot;) ~ plus ~ side.log(&quot;SIDE 2&quot;)</code> if the parser is used in multiple places and you only want to log this usage.</li>
            <li>
                Look at the logging, see some parser behaving strangely. Go to 1.
</li></ol>
        <p>
            In general, you do not want to add too many <code>.log()</code> calls otherwise the
            output becomes noisy and verbose and hard to understand. Adding them incrementally
            helps you narrow down the problem while still keeping the output readable.
</p>
    <h1 id="Tracing" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Tracing" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Tracing</h1>
        <p>
            By default, on failure, FastParse only provides the index and the last parser which failed at that index. This is information FastParse already has and is thus cheap to provide, and often is enough to show what went wrong, and where. If you prefer row &amp; column, you can trivially compute that from the input &amp; index by counting newlines inside the input string.</p>
        <p>
            Often you want something more, though, and for that FastParse provides tracing, as described in the documentation of <a href="#ParsingResults">Parsing Results</a>. By accessing the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.traced</code> lazy val on a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code>, FastParse will perform a whole second parse on the original input, starting from the same index, but with additional tracing code to keep track of what's happening. This typically costs ~2x as much as the original parse, so isn't done by default, but it's trivial to ask for it.</p>
        <p>
            For example, this is tracing being done on an invalid input we know will fail:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">val Parsed.Failure(expected, idx, extra) = Foo.expr.parse(&quot;(1+(2+3x))+4&quot;)</code></pre>
        <p>
            We know that this input will fail, because our grammar (defined earlier) does not contain an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;x&quot;</code> in it! It only handles numbers and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;+&quot;</code> and parentheses. <code>expected</code> gives us the parser that it needed in order to continue (with a readable <code>.toString</code>) and <code>idx</code> the index that it failed at:</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&gt; (idx, expected) // Last index and last parser at which it failed
(7, &quot;)&quot;)</code></pre>
        <p>
            But there is also the <code>extra</code> result which contains additional information you can use, e.g. the <code>extra.traced</code> result.
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&gt; extra.traced.trace // The named parsers in the stack when it failed
expr:1:1 / side:1:1 / expr:1:2 / side:1:4 / (&quot;)&quot; | CharIn(&quot;0123456789&quot;)):1:8 ...&quot;x))+4&quot;

&gt; extra.traced.stack // Same as .trace, but as a List[Frame] rather than String
Vector(
  Frame(0,expr), // (1+(2+3x))+4
  Frame(0,side), // (1+(2+3x))+4
  Frame(1,expr), //  1+(2+3x))+4
  Frame(3,side)  //    (2+3x))+4
)
</code></pre>
        <p>
            As you can see, tracing gives us a much more detailed view: every parser in the stack when the parse failed, what indices they were tried at. Apart from getting it as a readable string via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.trace</code>, you can also get it as structured data via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.stacK</code> in case you want to manipulate it programmatically.</p>
        <p>
            FastParse also provides the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.traceParsers</code> value, which tells you every single parser which <i>could</i> have succeeded at the index parsing failed. In thi</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&gt; fail.traced.traceParsers // Every parser that could have succeeded at Failure#index
Set(&quot;)&quot;, CharIn(&quot;0123456789&quot;))</code></pre>
        <p>
            Thus, we can see that although FastParse last tried the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;)&quot;</code> parser, it earlier <i>also</i> tried the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharIn(&quot;0123456789&quot;)</code> parser at the same spot. This makes perfect sense: if instead of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;x&quot;</code> we had a digit of some kind, parsing could have continued! And we do not need to figure this out ourselves; FastParse knows and can tell you.</p>
        <p>
            Lastly, tracing gives you access to the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.fullStack</code> of the failure, which contains <i>every</i> parser in the stack when it failed, not just the ones with names!</p>
        <p>
            Every expression in a fastparse parser is itself a parser: <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot;</code> is a parser, <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">&quot;(&quot; ~ expr ~ &quot;)&quot;</code> is a parser, and so on. With <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.fullStack</code>, we can see in great detail what FastParse was trying to do when it failed:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">&gt; extra.traced.fullStack // Every single parser in the stack when it failed
Vector(
  Frame(0,expr), Frame(0,expr),                    Frame(0,side ~ plus ~ side),
  Frame(0,side), Frame(0,&quot;(&quot; ~/ expr ~ &quot;)&quot; | num), Frame(1,&quot;(&quot; ~/ expr ~ &quot;)&quot;),
  Frame(1,expr), Frame(1,expr),                    Frame(3,side ~ plus ~ side),
  Frame(3,side), Frame(3,&quot;(&quot; ~/ expr ~ &quot;)&quot; | num), Frame(7,&quot;(&quot; ~/ expr ~ &quot;)&quot;)
)
</code></pre>
    <h1 id="InstrumentingParsers" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#InstrumentingParsers" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Instrumenting Parsers</h1>
        <p>
            FastParse provides an <code>instrument</code> argument, which you can
            use to inject a callback that lets you run code before or after
            every named parse (defined inside a <code>P</code>) is called. This can
            be used for a wide variety of things. For example, you could use it
            to count how many times each parser in the example <a href="#Math">Math</a>
            parser gets called when you parse a simple arithmetic expression:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val callCount = mutable.Map.empty[String, Int]


val instrumentFunction = (parser: Parser[_], index: Int, continuation: () =&gt; Parsed[_]) =&gt; {
  callCount(parser.toString) = callCount.getOrElse(parser.toString, 0) + 1
}

expr.parse(&quot;((1+1*2)+(3*4*5))/3&quot;, instrument = instrumentFunction)

val expectedCallCount = Map(
  &quot;expr&quot; -&gt; 1,
  &quot;addSub&quot; -&gt; 4,
  &quot;divMul&quot; -&gt; 6,
  &quot;factor&quot; -&gt; 10,
  &quot;number&quot; -&gt; 10,
  &quot;parens&quot; -&gt; 3
)
assert(callCount == expectedCallCount)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L72-L90" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            This is useful as FastParse isn't really profile-able by &quot;normal&quot;
            profilers: they tend to tell you what <i>kind</i> of parsers are getting
            called a lot and taking up all your time (e.g. <code>Sequence</code>,
            <code>Either</code>, ...) but not <i>which</i> of your parsers (e.g.
            <code>expr</code>, <code>numbers</code>) are getting called and taking up time.
            By using <code>instrument</code>, you can perform these counts yourself,
            even keeping track of <code>System.nanoTime</code>s if you want to count
            the actual time being taken.
</p>
        <p>
            The above example runs code <i>before</i> each named <code>P(...)</code>
            parser is run. The instrument callback also provides a
            <code>continuation</code> callback as its third argument, which you can
            use to run the current parser and run code <i>after</i> the parser is
            run:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">val resultCount = mutable.Map.empty[(String, Boolean), Int]
val instrumentFunction = (parser: Parser[_], index: Int, continuation: () =&gt; Parsed[_]) =&gt; {
  val result = continuation()
  val resultKey = (parser.toString, result.isInstanceOf[Parsed.Success[_]])
  resultCount(resultKey) = resultCount.getOrElse(resultKey, 0) + 1
}</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L92-L99" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            In this case, we are using it to count not just how many times each
            named <code>P(...)</code> parser is run, but also how many times it
            succeeds and fails. We can parse a &quot;good&quot; input and see that
            most of the attempts by named parser succeed:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// Good Parse
expr.parse(&quot;((1+1*2)+(3*4*5))/3&quot;, instrument = instrumentFunction)

val expectedResultCount = Map(
  (&quot;expr&quot;, true) -&gt; 1,
  (&quot;addSub&quot;, true) -&gt; 4,
  (&quot;divMul&quot;, true) -&gt; 6,
  (&quot;factor&quot;, true) -&gt; 10,
  (&quot;number&quot;, true) -&gt; 7,
  (&quot;number&quot;, false) -&gt; 3,
  (&quot;parens&quot;, true) -&gt; 3
)
assert(resultCount == expectedResultCount)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L99-L113" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            And we can parse invalid input, and see that it results in many of
            the named parsers failing repeatedly in the course of the parse:
</p>
        <pre class=" scalatex-site-Styles-hoverContainer"><code class="scala scalatex-site-Styles-highlightMe">// Bad Parse
resultCount.clear()
expr.parse(&quot;((1+1*2)+(3*4*))/3&quot;, instrument = instrumentFunction)

val expectedResultCount2 = Map(
  (&quot;expr&quot;, false) -&gt; 1,

  (&quot;addSub&quot;, true) -&gt; 1,
  (&quot;addSub&quot;, false) -&gt; 3,

  (&quot;divMul&quot;, true) -&gt; 3,
  (&quot;divMul&quot;, false) -&gt; 3,

  (&quot;factor&quot;, true) -&gt; 6,
  (&quot;factor&quot;, false) -&gt; 3,

  (&quot;number&quot;, true) -&gt; 5,
  (&quot;number&quot;, false) -&gt; 4,

  (&quot;parens&quot;, true) -&gt; 1,
  (&quot;parens&quot;, false) -&gt; 3
)
assert(resultCount == expectedResultCount2)</code><a class=" scalatex-site-Styles-headerLink" style="position: absolute;right: 0.5em;top: 0.5em;display: block;font-size: 24px;" href="https://github.com/lihaoyi/fastparse/tree/master/fastparse/shared/src/test/scala/fastparse/MathTests.scala#L113-L136" target="_blank"><i class="fa fa-link "></i></a></pre>

        <p>
            Which is what you would expect, since the parse overall failed!
            This measurement of pass/fail rates for each parser is a useful
            tool for understanding how the overall parser behaves at runtime:
            which individual parsers are being used over and over and are worth
            optimizing, and which are called only a handful of times and not
            bothering with. If an individual parser is being called over and
            over, you could optimize its internals to make it faster, or you
            could try to refactor the rest of the overall parser so this
            individual parser gets called fewer times.
</p>
        <p>
            In this case we only run code after the parser has completed,
            but we could easily run code both before and after if we wanted
            to e.g. measure the time each parser took to complete. You could
            also put <code>println</code>s inside your <code>instrument</code> callback
            to build your own custom logging functionality, if for some reason
            the <a href="#UsingLog">default logging</a> was not to your liking.
</p>
        <p>
            Instrumenting parsers typically isn't something you want to
            use on a &quot;production&quot; parser. Apart from slowing the parser down,
            it also is relatively unsafe: every <code>instrument</code> call is
            given untyped <code>Parser[_]</code> and <code>Parsed[_]</code> values, which
            you would need to cast to make any use of. It is generally both
            safer and more performant to build your parser result using
            <a href="#Capture">Capture</a>, <a href="#Map">Map</a> and <a href="#FlatMap">FlatMap</a>.</p>
        <p>
            Nevertheless, <code>instrument</code> it is still a useful tool to
            have available in your toolbox if you are unsure of what a
            parser is doing, and can be used to give you insight into
            the runtime behavior of your parsers which is hard to get
            otherwise.

</p>
    <h1 id="UseCases" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#UseCases" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Use Cases</h1>
        <p>
            What's the purpose of all this detailed error reporting? The goal is three-fold:</p>
        <ul>
            <li>
                You will want to know why parsers as misbehaving while you're writing them so you can fix bugs. Often <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.traced.trace</code> is enough, but you can dig in more deeply if you wish to.</li>
            <li>
                You can use the detailed error traces to your users when they enter invalid input. For example, instead of just <i>&quot;Syntax error at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">7</code>&quot;</i> You can say <i>&quot;Syntax error at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">7</code>, expected <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(&quot;)&quot; | CharIn(&quot;0123456789&quot;)</code>, while trying to parse a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side</code> at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">3</code>, while trying to parse an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">expr</code> at column <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">1</code>, ...&quot;</i>. Naturally, you do not need to overwhelm the user with debug information, but now you have the power to reveal as much or as little as you want.
</li>
            <li>
                You can customize the experience of your users when they enter invalid input! For example, if I know that the rule <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">side</code> failing <i>usually</i> means the user made some common mistake, I can easily check for that via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fail.traced.stack.contains(_.parser == Foo.side)</code> and display a more helpful error <i>&quot;Maybe try X?&quot;</i> if it's found. No need to embed your error-reporting deep in the parser, just inspect the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">stack</code> and find out after the fact.</li></ul>
        <p>
            In general, FastParse's error reporting is detailed and structured. As a <i>developer</i>, most of your time spent interacting with your parser is when it is incorrect and throwing errors at you. As a <i>user</i>, most of your time spent interacting with the parser is when your input is incorrect and it is throwing errors at you. This is almost self-evident, since once your parser is correct or your input is correct you're done and go do other things</p>
        <p>
            Thus, FastParse makes an effort to make the error reporting both detailed and structured. This means as a developer you can quickly diagnose problems, and (if you wish to) put in effort to use the structured errors to help <i>your users</i> diagnose problems. That makes life better for everybody.</p>


    
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Comparisons" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Comparisons<a class=" scalatex-site-Styles-headerLink" href="#Comparisons" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        FastParse differs from all other parser-combinator libraries in the Scala universe, in quite substantial ways:
</p>
    <ul>
        <li>
            Compared to <a href="https://github.com/sirthias/parboiled2">Parboiled2</a>, FastParse does not use macros to compile-time-generate fast parser code. Rather, it acts as an efficient interpreter, sacrificing some speed (1-4x slower) for huge amounts of usability. Parboiled2 in particular has <a href="https://groups.google.com/forum/#!msg/scala-internals/4N-uK5YOtKI/9vAdsH1VhqAJ">usability problems and bugs</a> that make it excruciating difficult to use, and also does not support higher-order rules. FastParse suffers from none of these problems.</li>
        <li>
            <a href="https://github.com/sirthias/parboiled/wiki">Parboiled1</a> is a Java library, and does not/cannot work on Scala.js</li>
        <li>
            <a href="https://github.com/scala/scala-parser-combinators">scala-parser-combinators</a> is similar, but poorly executed. It is ~100x slower than FastParse, has an awkward inheritance-based API, and is full of bugs despite being half a decade old. FastParse is faster, has self-contained pure-functional parsers, and fixes bugs e.g. by having the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code> operator actually work.</li></ul>


    
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="Internals" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Internals<a class=" scalatex-site-Styles-headerLink" href="#Internals" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <p>
        FastParse's internals are straightforward. Nonetheless, its design is unlike any other combinator library I've seen: externally immutable, pure-functional parser-combinators with mutable, highly-optimized internals.

</p>
    <h1 id="FastInterpreter" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#FastInterpreter" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Fast Interpreter</h1>
        <p>
            FastParse is designed as a fast, immutable interpreter. That means</p>
        <ul>
            <li>
                It does not do significant transformations of the grammar. The structure of the parser you define is the structure that will run. No transformation at compile time, no transformations at run-time.</li>
            <li>
                It provides fast primitives like <a href="#CharsWhile">CharsWhile</a>, that you can drop in many places to speed up otherwise slow bulk operations (e.g. parsing whitespace, identifiers).</li>
            <li>
                Error reported is straightforward: the last index that it does not backtrack out of is the index that is reported, and the parser at that point is the parser that is reported.
</li></ul>
        <p>
            In theory, it could be possible to perform either compile-time or initialization-time (before actually parsing) optimizations on the parser to improve performance. So far, I have not managed to find a scheme that has a significant improvement at an acceptable cost in terms of complexity. Apart from trivial de-sugarings (e.g. merging together <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">(p1 | p2) | p3</code> into a single <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Either</code> node) what you write is what gets run
</p>
    <h1 id="ExternalImmutabiliy" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ExternalImmutabiliy" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>External Immutabiliy</h1>

        <p>
            FastParse presents a pure-functional, immutable external API to the user. That means that you can call <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]#parse</code> and not worry about having to set up neccessary state or instantiating objects. You take a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T]</code>, call <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.parse</code>, and get a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Success[T]</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code>
</p>
        <p>
            However, immutability poses a challenge: immutability usually involves lots of &quot;copy &amp; update&quot; operations rather than &quot;mutation&quot; operations, and on the JVM that means excessive garbage generation and collection. This is harmful for performance.
</p>
        <p>
            Thus FastParse performs some tricks internally to save allocations: the immutable <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Success</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Failure</code> result types are actually interfaces hiding <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Success</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Failure</code> implementations, which have entirely mutable fields.
</p>
        <p>
            This means that the same <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Success</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Failure</code> objects are shared throughout an entire parsing run, mutated as the parse progresses, while the external user only sees an immutable facade. This also means that a run of the large-and-complex <a href="#ScalaParse">ScalaParse</a> on a hundreds-of-kb source file results in exactly <i>three</i> allocations in all: one <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Success</code>, one <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.Mutable.Failure</code>, and one <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Ctx</code> object holding them together.
</p>
    <h1 id="InternalOptimizations" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#InternalOptimizations" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Internal Optimizations</h1>
        <p>
            FastParse does some things that take advantage of the type-directed nature of the result-aggregation: while <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[T].rep</code> returns a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Seq[T]]</code> for an arbitrary <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">T</code>, there is a short circuit such that <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Unit].rep</code> simple returns <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[Unit]</code>. This lets the common case of &quot;parsing things, not caring about the result&quot; avoid the allocation, while still allowing you to stick some other type in there (e.g. <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Any</code>) if you really do care about the bucket-of-<code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Unit</code>s.
</p>
        <p>
            FastParse also takes advantage of the fact that <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>s are immutable. That makes it feasible to make instantiation mildly-expensive, since each one only gets instantiated once rather than per-parse. As an example, <a href="#CharIn">CharIn</a>, <a href="#CharPred">CharPred</a> and <a href="#CharsWhile">CharsWhile</a> all have their predicate converted to an identical bit-set to make character lookups extremely fast. Similarly, <a href="#StringIn">StringIn</a> gets converted into a Trie in order to allow one-pass matching of dozens of strings at the same time.</p>
        <p>
            These operations are not cheap: the bitsets easily take a few KB of memory each, and involve 65k iterations to fill them in. However, since <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser</code>s are immutable, this one-time-cost goes from &quot;ridiculous&quot; to &quot;acceptable&quot;. All these internal optimizations are completely opaque to the user, who (apart from performance) never need to think about them.
</p>
    <h1 id="ParsingOnly" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#ParsingOnly" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Parsing Only</h1>
        <p>
            Fastparse, unlike libraries like <a href="https://github.com/scodec/scodec">Scodec</a>
            or Python's <a href="https://pypi.python.org/pypi/construct">Construct</a>,
            only allows you to define how to parse data from serialized
            text/bytes into structured data, and not the other way around.
</p>
        <p>
            It is probably possible to write a wrapper on top of FastParse
            that will allow two-directional serialization, but such a thing
            does not exist right now in the FastParse codebase, and would
            likely be pretty difficult to design and implement. If you need
            such a thing you could try writing your own wrapper and (if it
            works out well) contributing it back to FastParse, or otherwise
            just use something else like
            <a href="https://github.com/scodec/scodec">Scodec</a>
            which has this capability build in.
</p>
    <h1 id="Abstraction" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#Abstraction" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>Abstraction</h1>
        <p>
            FastParse's basic parsers are all generic: things like
            <a href="#Sequence">Sequence</a>, <a href="#Repeat">Repeat</a>, <a href="#Optional">Optional</a>,
            etc. are written to work on any sort of input, whether parsing
            <code>String</code>s or <code>Array[Byte]</code>. The <code>Parser</code> and
            <code>Result</code> types are themselves generic and can work on multiple
            input and output types, hence the rather complex signatures:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">trait Parser[+T, Elem, Repr]
sealed trait Parsed[+T, Elem]</code></pre>
        <p>
            From this generic baseline, FastParse defines multiple &quot;Api&quot;
            modules. Each of these specializes the &quot;generic&quot; FastParse API
            into something that's more convenient for a task at hand:
</p>
        <ul>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.all._</code> for parsing <code>String</code>s</li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.noApi._</code> for parsing <code>String</code>s,
                in combination with custom <a href="#WhitespaceHandling">Whitespace Handling</a></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.byte.all._</code> for parsing <a href="#Bytes">Bytes</a>
</li></ul>
        <p>
            Each FastParse API has type aliases that narrow the type for its particular
            use case: e.g. <code>fastparse.all</code> has aliased:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">type Parsed[+T] = core.Parsed[T, String]
type Parser[+T] = core.Parser[T, Char, String]</code></pre>
        <p>
            While <code>fastparse.byte</code> has aliased:
</p>
        <pre><code class="scala scalatex-site-Styles-highlightMe">type Parsed[+T] = core.Parsed[T, Array[Byte]]
type Parser[+T] = core.Parser[T, Byte, Array[Byte]]
</code></pre>
        <p>
            Thus, you generally can worked directly with the aliases defined
            in the relevant Api module without worrying about the more
            generic form, though most of the core parsers are written
            generically to work in any Api module. If you wished to, you
            too could write a custom parser that can parse both <code>String</code>s
            and <code>Array[Byte]</code>, by inheriting from the more generic
            <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser[+T, Elem, Repr]</code> trait.
</p>
        <p>
            Apart from the direct aliases, FastParse also provides alternate names
            for the &quot;generic versions&quot; of some of the common parsers:
</p>
        <ul>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">AnyElem</code> for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">AnyChar</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">AnyByte</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ElemPred</code> for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharPred</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">BytePred</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ElemIn</code> for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharIn</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ByteIn</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ElemsWhile</code> for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhile</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">BytesWhile</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">ElemsWhileIn</code> for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">CharsWhileIn</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">BytesWhileIn</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">SeqIn</code> for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">StringIn</code>
</li></ul>
        <p>
            This is for backwards compatibility, and to allow you to use
            more relevant names when writing your parser (e.g. <code>AnyChar</code>
            instead of <code>AnyElem</code>).</p>


    
<div style="margin: 0px;color: #333;text-align: center;padding: 2.5em 2em 0;border-bottom: 1px solid #eee;display: block;" id="ChangeLog" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><h1 style="margin: 0.2em 0;font-size: 3em;font-weight: 300;">Change Log<a class=" scalatex-site-Styles-headerLink" href="#ChangeLog" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a></h1><br /></div>
    <h1 id="0.4.4" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.4</h1>
        <ul>
            <li>
                Scala Native support for the modules: <code>fastparse</code>,
                <code>scalaparse</code>, <code>pythonparse</code> and <code>cssparse</code>.
                Porting to Scala Native required no diffs in the source code,
                only build modifications. This release should be identical to
                0.4.3.
</li></ul>
    <h1 id="0.4.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.3</h1>
        <ul>
            <li>
                Added documentation on <a href="#ImprovingPerformance">Improving Performance</a> and
                <a href="#StartupPerformance">Startup Performance</a>, along with many micro-optimizations
                and additional tools (below) for improving startup performance. Using these
                tools &amp; techniques, you can expect about a 10x reduction in time
                taken to initialize your FastParse parsers. This is particularly
                relevant for using FastParse in interactive websites via Scala.js.
</li>
            <li>
                Added <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.CharPredicates</code>, which provides faster
                versions of methods like <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.isDigit</code> or <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.isUpper</code>
                which tend to be slow on Scala.js
</li>
            <li>
                Added a <a href="#CharsWhileIn">CharsWhileIn</a> (and the corresponding <code>BytesWhileIn</code>)
                operator: a hybrid between <a href="#CharsWhile">CharsWhile</a> and <a href="#CharIn">CharIn</a>.
                This should make it more convenient to continually consume characters
                within a certain set.
</li>
            <li>
                Added <code>CharsWhile.raw</code>, <code>CharPred.raw</code>
                intrinsics, which are identical to the non-<code>raw</code> versions except
                these do not pre-compute a lookup table for use during parsing. This
                could be useful if you find your parsers are taking too long to
                initialize and don't mind sacrificing a bit of steady-state
                performance.
</li>
            <li>
                Trailing comma support for ScalaParse, thanks to
                <a href="https://github.com/dwijnand">Dale Wjinand</a>
</li>
            <li>
                Removed unnecessary runtime dependency from CssParse on
                <code>net.sourceforge.cssparser</code>, since we were only using it
                in tests, thanks to <a href="https://github.com/ritschwumm">ritschwumm</a></li>
            <li>
                Tightening up Scalaparse: added some cuts to improve the error
                positioning after semicolons within for-comprehensions,
                reduced the number of places postfix expressions were allowed by our
                parser to better reflect the actual Scala grammar
</li></ul>
    <h1 id="0.4.2" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.2</h1>
        <ul>
            <li>
                Cross-publish for Scala 2.12.x</li></ul>
    <h1 id="0.4.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.1</h1>
        <ul>
            <li>
                Fix off-by-one error in generation of <code>line:col</code> indices
                in error traces for string parsing</li>
            <li>
                Make <code>.log()</code> use the same <code>line:col</code> indices during
                string-parsing that error traces do, for consistency</li>
            <li>
                Optimize <code>line:col</code> message generation to avoid
                unnecessary allocations and copying.
</li></ul>
    <h1 id="0.4.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.4.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.4.0</h1>
        <ul>
            <li>
                New <a href="#CssParse">CssParse</a> in cssparse module, as an example CSS parser
                written using FastParse.
</li>
            <li>
                FastParse now supports <a href="#ByteParsers">Byte Parsers</a>! You can parse
                binary data using FastParse, using all the same operators and
                combinators you may already be familiar with
</li>
            <li>
                New <a href="#MidiParse">MidiParse</a>, <a href="#BmpParser">BmpParser</a> and
                <a href="#ClassParser">ClassParser</a> example parsers, as working examples of
                how Fastparse's new <a href="#ByteParsers">Byte Parsers</a> are written.
</li>
            <li>
                Support for <a href="#StreamingParsing">Streaming Parsing</a>
</li>
            <li>
                Many internal refactors in order to support the new
                <a href="#ByteParsers">Byte Parsers</a> and <a href="#StreamingParsing">Streaming Parsing</a>.
                <code>Parser</code> and <code>ParserApi</code> are now
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">abstract class</code>es instead of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">trait</code>s, and
                take implicits that are necessary for them to operate.
</li>
            <li>
                Many of the original types have been moved from the
                <code>fastparse</code> package into <code>fastparse.core</code>, and have
                grown additional type-parameters and implicits. If you
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.all._</code> or
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.byte.all._</code>, that should include
                aliases for most of the useful objects and types with the
                relevant type-parameters set to the correct values, and bring
                in the necessary implicits for things to work.
</li>
            <li>
                The old <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def wspStr(s: String): P0</code> implicit has been
                renamed <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">def LiteralStr(s: String): P0</code>; the old name was a
                copy-paste from scala-parser-combinators, and never made much
                sense anyway
</li>
            <li>
                <a href="#Unapply">Unapply</a> method to allow pattern matching on parsers,
                thanks to <a href="https://github.com/volth">volth</a>.
</li>
            <li>
                Added a <code>StringInIgnoreCase</code> parser to allow matching
                on multiple strings like <a href="#StringIn">StringIn</a> but case-insensitively,
                thanks to <a href="https://github.com/jimdickinson">Jim Dickinson</a>.
</li></ul>
    <h1 id="0.3.7" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.7</h1>
        <ul>
            <li>
                Bump version of <code>sourcecode</code> from <code>0.1.0</code> to <code>0.1.1</code></li></ul>
    <h1 id="0.3.6" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.6</h1>
        <ul>
            <li>
                Fix <b>#77</b>: deduplicate traceParsers in WhitespaceAPI to prevent stack overflow, by <a href="https://github.com/jeroenr">Jeroen Rosenberg</a></li></ul>
    <h1 id="0.3.5" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.5" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.5</h1>
        <ul>
            <li>
                Minor improvements to error-reporting in Scalaparse; error messages inside tuple-types and refinement-types should be slightly more precise</li></ul>
    <h1 id="0.3.4" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.4" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.4</h1>
        <ul>
            <li>
                Fix <b>#69</b>: performance problem in the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">StringsIn</code> parser, which resulted in initialization time exponential relative to the length of the longest string, by <a href="https://github.com/rklaehn">Rudiger Klaehn</a></li></ul>
    <h1 id="0.3.3" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.3" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.3</h1>
        <ul>
            <li>
                <b>#66</b> Bugfix: <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser.rep</code> now handles max=0 properly, by <a href="https://github.com/ProjectZetta/">Martin Senne</a>
</li>
            <li>
                Further restructuring of <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed.Result</code> by <a href="https://github.com/ProjectZetta/">Martin Senne</a>
                 <ul>
                     <li>
                         Object <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result</code> has been renamed to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>
</li>
                     <li>
                         Former <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result</code> has moved to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parsed</code>.
</li>
                     <li>
                         Methods for position retrieval <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">line</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">col</code> have moved to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure.Extra</code>
</li></ul></li>
            <li>
                <b>#59</b> Fix <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.core.Result.Failure.formatParser()</code> throwing <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">UnsupportedOperationException</code> on receiving an empty string as an input, by <a href="https://github.com/solar">solar</a></li>
            <li>
                <b>#61</b> Added the <a href="#Opaque">Opaque</a> combinator, which allows to provide more high-level error messages, by <a href="https://github.com/stanch">Nick Stanch</a></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure</code> has been restructured: Less-commonly-used properties like <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">input</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">traced</code> have been aggregated into an <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure.Extra</code> object, simplifying pattern matching. By <a href="https://github.com/ProjectZetta/">Martin Senne</a>
</li></ul>
    <h1 id="0.3.2" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.2" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.2</h1>
        <ul>
            <li>
                Slightly better parsing of triple-quote strings in Scalaparse</li>
            <li>
                Added an alias for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">type Result[T]</code> to match the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">val Result</code> inside <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.all</code></li></ul>
    <h1 id="0.3.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.3.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.3.1</h1>
        <ul>
            <li>
                <b>#47</b> Upgraded to Scala.js 0.6.5, removed unnecessary <code>CharPredicate</code>s</li>
            <li>
                <b>#42</b> Renamed <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">a ~! b</code> to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">a ~/ b</code> to avoid confusion with <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">a ~ !b</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Failure</code> objects now expose the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.line</code> and <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.col</code> attributes, in addition to the raw <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.index</code>, and display these in the default trace messages</li>
            <li>
                <b>#27</b> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.rep</code> now can take a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">max</code> in addition to a <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">min</code></li>
            <li>
                <b>#40</b> <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log</code> now properly displays the proper snippet of text when propagating failure upward</li></ul>
    <h1 id="0.2.1" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.1" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.1</h1>
        <ul>
            <li>
                Simplified ScalaParse internals slightly</li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Parser#get</code> now throws a custom <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">SyntaxError</code> with relevant metadata, instead of a plain <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Exception</code></li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">WhitespaceApi</code>'s <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">WL</code> value no longer leaks out when you import from it</li></ul>
    <h1 id="0.2.0" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.2.0" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.2.0</h1>
        <ul>
            <li>
                Default import changed from <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse._</code> to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.all._</code>, to make space for <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.noApi._</code></li>
            <li>
                Major changes to parser internals: the internal representation of parse results in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Mutable.{Success, Failure}</code> has been split off from the immutable external represenation <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.{Success, Failure}</code></li>
            <li>
                Error-reporting has been overhauled, and is greatly improved at the cost of being more expensive. Detailed errors now require a second parse with instrumentation</li>
            <li>
                The cheap &amp; spartan error data in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure</code> has been split out from the expensive but detailed error traces in <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Result.Failure#traced</code>.</li>
            <li>
                <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.log()</code> now uses the parser's own <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">.toString</code> by default if you don't pass in a tag, for convenience.</li>
            <li>
                Added the ability to exclude the default parser operators via <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">import fastparse.noApi._</code>, allowing you to import custom sets of operators tailored to your needs.</li>
            <li>
                Introduced the <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.WhitespaceApi</code> class, which replaces the default set of operators with a new set which eagerly consumes whitespace between parsers.</li>
            <li>
                Updated ScalaParse to use <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">fastparse.WhitespaceApi</code>, resulting in much more precise error locations. Errors are now positioned before the characters which failed, rather than before the preceding whitespace, and syntax errors in comments now provide better errors</li>
            <li>
                Added unit tests and examples/demos of <a href="#WhitespaceHandling">Whitespace Handling</a> and <a href="#IndentationGrammars">Indentation Grammars</a></li>
            <li>
                Added <a href="#Filter">Filter</a> to the API, to complement <a href="#Map">Map</a> and <a href="#FlatMap">FlatMap</a></li></ul>
    <h1 id="0.1.7" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.1.7" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.1.7</h1>
        <ul>
            <li>
                More fixes for ScalaParse, added more projects to test suite</li>
            <li>
                Auto-generate <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">Sequencer</code> instances up to 22</li>
            <li>
                Removed unnecessary runtime utest dependency</li></ul>
    <h1 id="0.1.6" style="display: block;" class=" scalatex-site-Styles-hoverContainer scalatex-site-Styles-headerTag"><a class=" scalatex-site-Styles-headerLink" href="#0.1.6" style="position: absolute;right: 0px;"><i class="fa fa-link"></i></a>0.1.6</h1>
        <ul>
            <li>
                Introduced five new projects into the test suite: ScalaIDE, GitBucket, Scalding, Scaloid, Marathon</li>
            <li>
                Fixed bug in ScalaParse around using function <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">=&gt;</code> types as type ascriptions</li>
            <li>
                Added ability to <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">instrument</code> parsers, in order to gather out-of-band information about them e.g. for debugging or profiling</li>
            <li>
                Added <code class="scala scalatex-site-Styles-highlightMe" style="display: inline;padding: 0px;margin: 0px;">IgnoreCase</code> combinator, for case-insensitive string matching</li>
            <li>
                Cross-published for Scala 2.10</li></ul>

</div>
</div><script>
    scalatex.scrollspy.Controller().main(
      [{"value":"FastParse 0.4.4","children":[{"value":"Getting Started","children":[]},{"value":"Writing Parsers","children":[{"value":"Basic","children":[{"value":"Sequence","children":[]},{"value":"Repeat","children":[]},{"value":"Optional","children":[]},{"value":"Either","children":[]},{"value":"End, Start","children":[]},{"value":"Pass, Fail","children":[]},{"value":"Index","children":[]},{"value":"Capture","children":[]},{"value":"AnyChar","children":[]},{"value":"Positive Lookahead","children":[]},{"value":"Negative Lookahead","children":[]},{"value":"Map","children":[]},{"value":"FlatMap","children":[]},{"value":"Filter","children":[]},{"value":"Opaque","children":[]},{"value":"Log","children":[]}]},{"value":"Intrinsics","children":[{"value":"CharPred","children":[]},{"value":"CharIn","children":[]},{"value":"CharsWhile","children":[]},{"value":"CharsWhileIn","children":[]},{"value":"StringIn","children":[]}]},{"value":"Cuts","children":[{"value":"No Cuts","children":[]},{"value":"Cuts","children":[]},{"value":"Rep Cuts","children":[]},{"value":"Isolating Cuts","children":[]}]},{"value":"Unapply","children":[]}]},{"value":"Streaming Parsing","children":[{"value":"Streaming Parsing Buffer Size","children":[]},{"value":"Streaming Parsing Performance","children":[]},{"value":"Streaming Parsing Limitations","children":[]}]},{"value":"Example Parsers","children":[{"value":"Math","children":[]},{"value":"Whitespace Handling","children":[]},{"value":"Indentation Grammars","children":[]},{"value":"Json","children":[]},{"value":"ScalaParse","children":[{"value":"Using ScalaParse","children":[]}]},{"value":"PythonParse","children":[]},{"value":"CssParse","children":[]}]},{"value":"API Highlights","children":[{"value":"Parser","children":[]},{"value":"ParserApi","children":[]},{"value":"Parsing Results","children":[]}]},{"value":"Byte Parsers","children":[{"value":"Bytes","children":[]},{"value":"Byte Helpers","children":[{"value":"Hex Bytes","children":[]},{"value":"prettyBytes","children":[]}]},{"value":"Byte-Specific Parsers","children":[{"value":"BS","children":[]},{"value":"WordN","children":[]},{"value":"IntN","children":[]},{"value":"FloatN","children":[]}]},{"value":"Equivalent Byte Parsers","children":[{"value":"Simple Bytes","children":[]},{"value":"Sequence Bytes","children":[]},{"value":"Repeat Bytes","children":[]},{"value":"Optional Bytes","children":[]},{"value":"Either Bytes","children":[]},{"value":"End/Start Bytes","children":[]},{"value":"Pass/Fail Bytes","children":[]},{"value":"Index Bytes","children":[]},{"value":"Capture Bytes","children":[]},{"value":"Any Bytes","children":[]},{"value":"Positive Lookahead Bytes","children":[]},{"value":"Negative Lookahead Bytes","children":[]},{"value":"Map Bytes","children":[]},{"value":"Filter Bytes","children":[]},{"value":"FlatMap Bytes","children":[]},{"value":"BytesWhile","children":[]},{"value":"BytesWhile","children":[]},{"value":"BytePred","children":[]}]},{"value":"Example Byte Parsers","children":[{"value":"UDP Packets","children":[]},{"value":"BmpParser","children":[{"value":"BmpParser Walkthrough","children":[]}]},{"value":"MidiParse","children":[]},{"value":"ClassParser","children":[]}]}]},{"value":"Performance","children":[{"value":"Improving Performance","children":[]},{"value":"Startup Performance","children":[]}]},{"value":"Debugging Parsers","children":[{"value":"Using Cuts","children":[]},{"value":"Using Log","children":[]},{"value":"Tracing","children":[]},{"value":"Instrumenting Parsers","children":[]},{"value":"Use Cases","children":[]}]},{"value":"Comparisons","children":[]},{"value":"Internals","children":[{"value":"Fast Interpreter","children":[]},{"value":"External Immutabiliy","children":[]},{"value":"Internal Optimizations","children":[]},{"value":"Parsing Only","children":[]},{"value":"Abstraction","children":[]}]},{"value":"Change Log","children":[{"value":"0.4.4","children":[]},{"value":"0.4.3","children":[]},{"value":"0.4.2","children":[]},{"value":"0.4.1","children":[]},{"value":"0.4.0","children":[]},{"value":"0.3.7","children":[]},{"value":"0.3.6","children":[]},{"value":"0.3.5","children":[]},{"value":"0.3.4","children":[]},{"value":"0.3.3","children":[]},{"value":"0.3.2","children":[]},{"value":"0.3.1","children":[]},{"value":"0.2.1","children":[]},{"value":"0.2.0","children":[]},{"value":"0.1.7","children":[]},{"value":"0.1.6","children":[]}]}]}]
  )</script><script>
    ['DOMContentLoaded', 'load'].forEach(function(ev){
      addEventListener(ev, function(){
        Array.prototype.forEach.call(
          document.getElementsByClassName('scalatex-site-Styles-highlightMe'),
          hljs.highlightBlock
        );
      })
    })
  </script></body></html>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         